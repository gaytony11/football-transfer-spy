<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>UK Football Situation — Live</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
<link href="https://fonts.cdnfonts.com/css/teletext" rel="stylesheet">

<style>
  :root{
    --bg:#000;
    --green:#00ff00;
    --yellow:#ffff00;
    --red:#ff0000;
    --cyan:#00ffff;
    --magenta:#ff00ff;
    --white:#ffffff;
  }

  body {
    margin: 0;
    background: var(--bg);
    color: var(--green);
    font-family: "Teletext","VT323", monospace;
    font-size: 18px;
  }

  h1 {
    margin: 10px;
    color: var(--yellow);
    font-size: 20px;
    letter-spacing: 1px;
  }

  #container {
    display: flex;
    height: calc(100vh - 124px);
  }

  #map { width: 70%; }

  #sidebar {
    width: 30%;
    padding: 10px 12px;
    border-left: 4px solid var(--green);
    overflow-y: auto;
  }

  /* ===== DIRECTORY ===== */
  .country-header:hover,
.league-header:hover {
  color: var(--white);
  text-decoration: underline;
  cursor: pointer;
}

  .country-header,
  .league-header {
    cursor: pointer;
    color: var(--yellow);
    display: flex;
    align-items: center;
    gap: 8px;
    user-select: none;
    padding: 4px 0;
  }

  .country-header .twisty,
  .league-header .twisty{
    width: 18px;
    display:inline-block;
    color: var(--cyan);
  }

  .country-header.active,
  .league-header.active {
    color: var(--red);
  }

  .league {
    padding-left: 14px;
    margin-bottom: 6px;
  }

  .club {
    padding-left: 34px;
    cursor: pointer;
    color: var(--green);
    padding-top: 2px;
    padding-bottom: 2px;
    display: flex;
    align-items: center;
    gap: 8px;
    user-select:none;
  }

  .club .club-dot{
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background: var(--green);
    flex: 0 0 auto;
    opacity: 0.9;
  }

  .club.active {
    color: var(--red);
    animation: blink 1.2s steps(1) infinite;
  }

  .club.active .club-dot{
    background: var(--red);
  }

  .club:hover { color: var(--white); }

  .count {
    color: var(--cyan);
    margin-left: 6px;
  }

  .flag,
  .league-crest {
    width: 18px;
    height: 18px;
    object-fit: contain;
    image-rendering: crisp-edges;
  }

  /* ===== CLUB VIEW ===== */
  .club-view-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
    margin-bottom: 8px;
  }

  .club-name {
    font-size: 22px;
    color: var(--yellow);
    margin: 0;
  }

  .back {
    cursor: pointer;
    color: var(--cyan);
    margin-bottom: 10px;
    user-select:none;
  }
  .back:hover{ color: var(--white); }

  /* ===== FEED ITEMS ===== */
  .rumour {
    border-bottom: 1px dashed var(--green);
    margin-bottom: 10px;
    padding-bottom: 8px;
  }

  .rumour a {
    color: var(--yellow);
    text-decoration: none;
  }

  .rumour a:hover {
    color: var(--red);
    text-decoration: underline;
  }

  .time {
    color: var(--cyan);
    font-size: 14px;
    margin-top: 4px;
  }

  .source {
    color: var(--magenta);
  }

  /* ===== TICKER ===== */
  #ticker {
    height: 88px;
    border-top: 4px solid var(--green);
    overflow: hidden;
    white-space: nowrap;
    display: flex;
    align-items: center;
    background: #000;
  }

  #ticker .scroll {
    display: inline-flex;
    align-items: center;
    gap: 16px;
    padding-left: 100%;
    animation: scroll 16s linear infinite;
  }

  #ticker a {
    display: inline-flex;
    align-items: center;
    gap: 16px;
    color: var(--yellow);
    text-decoration: none;
    font-size: 40px;
    letter-spacing: 2px;
  }

  #ticker a:hover { color: var(--red); }

  .ticker-icon {
    width: 52px;
    height: 52px;
    object-fit: contain;
    image-rendering: crisp-edges;
    flex: 0 0 auto;
  }

  @keyframes scroll {
    from { transform: translateX(0); }
    to   { transform: translateX(-100%); }
  }

  @keyframes blink {
    50% { opacity: 0.35; }
  }

  .club-logo img{ image-rendering: crisp-edges; }

  .hint{
    color: var(--cyan);
    font-size: 14px;
    opacity: 0.9;
    margin-top: 6px;
  }

  /* ===== MOBILE ADAPTATION ===== */
@media (max-width: 768px) {
  #container {
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
  }

  #map {
    width: 100%;
    height: 55vh; /* Prioritize map */
  }

  #sidebar {
    width: 100%;
    height: 45vh;
    overflow-y: auto;
    border-left: none;
    border-top: 4px solid var(--green);
  }

  h1 {
    font-size: 18px;
    text-align: center;
  }

  .club-name {
    font-size: 20px;
  }

  #ticker {
    height: 64px;
  }

  #ticker a {
    font-size: 28px;
  }

  .ticker-icon {
    width: 40px;
    height: 40px;
  }
}
@keyframes pulse-glow {
  0%   { background-color: rgba(255,255,0,0.1); }
  50%  { background-color: rgba(255,255,0,0.4); }
  100% { background-color: rgba(255,255,0,0.1); }
}

.pulse {
  animation: pulse-glow 1.5s ease-in-out;
}

/* Marker Bounce Highlight */
@keyframes bounceHighlight {
  0%   { transform: scale(1); }
  30%  { transform: scale(1.8) rotate(-5deg); }
  60%  { transform: scale(1.4) rotate(5deg); }
  100% { transform: scale(1); }
}

.leaflet-marker-icon.bounce-highlight {
  animation: bounceHighlight 1.2s ease-out;
  filter: drop-shadow(0 0 6px red);
  z-index: 9999;
}

/* Marker Pulse (used for sidebar dots if needed) */
@keyframes bouncePulse {
  0%   { transform: scale(1); }
  30%  { transform: scale(1.5) rotate(-2deg); }
  60%  { transform: scale(1.3) rotate(2deg); }
  100% { transform: scale(1); }
}
.selected-club {
  background-color: rgba(255, 255, 0, 0.1);
  border-left: 3px solid var(--yellow);
  animation: selectedPulse 1s ease-in-out;
}

@keyframes selectedPulse {
  0%   { opacity: 1; }
  50%  { opacity: 0.4; }
  100% { opacity: 1; }
}

.leaflet-marker-icon.pulse {
  animation: bouncePulse 0.8s ease-out;
  filter: drop-shadow(0 0 4px red);
  z-index: 1000;
}
/* Custom scrollbar for sidebar */
#sidebar::-webkit-scrollbar {
  width: 8px;
}
#sidebar::-webkit-scrollbar-thumb {
  background: var(--green);
  border-radius: 4px;
}
#sidebar::-webkit-scrollbar-track {
  background: var(--bg);
}
@keyframes mapBadgePulse {
  0%   { transform: scale(1); }
  20%  { transform: scale(1.9) rotate(-8deg); }
  40%  { transform: scale(1.5) rotate(6deg); }
  60%  { transform: scale(1.8) rotate(-3deg); }
  100% { transform: scale(1); }
}

.leaflet-marker-icon.map-highlight {
  animation: mapBadgePulse 1.4s ease-out;
  filter: drop-shadow(0 0 10px red);
  z-index: 9999;
}

/* ===== MAP BADGE STATES (Selected + News) ===== */
.leaflet-marker-icon.club-badge{
  background: transparent;
  border: none;
  border-radius: 50%;
}

.leaflet-marker-icon.club-badge .club-badge-inner{
  width: 100%;
  height: 100%;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transform-origin: 50% 50%;
}

.leaflet-marker-icon.club-badge .club-badge-img{
  width: 100%;
  height: 100%;
  display: block;
  object-fit: contain;
  image-rendering: crisp-edges;
}

@keyframes badgeSelectedPulse {
  0%, 100% { transform: translateY(0) scale(1.25); }
  50%      { transform: translateY(-2px) scale(1.34); }
}

@keyframes badgeSelectedPulseAlert {
  0%, 100% { transform: translateY(0) scale(1.35); }
  50%      { transform: translateY(-3px) scale(1.52); }
}

@keyframes badgeAlertScale {
  0%, 100% { transform: scale(1.35); }
  50%      { transform: scale(1.55); }
}

@keyframes badgeAlertPulse {
  0%, 100% {
    box-shadow: 0 0 0 0 rgba(255,0,0,0);
    filter: drop-shadow(0 0 6px rgba(255,0,0,0.35));
  }
  50% {
    box-shadow: 0 0 0 14px rgba(255,0,0,0.32), 0 0 22px 10px rgba(255,0,0,0.60);
    filter: drop-shadow(0 0 18px rgba(255,0,0,0.9));
  }
}

.leaflet-marker-icon.badge-selected{
  z-index: 2500;
}

.leaflet-marker-icon.badge-alert{
  z-index: 9999;
}

.leaflet-marker-icon.badge-selected .club-badge-inner{
  filter:
    drop-shadow(0 0 10px rgba(255,0,0,0.95))
    drop-shadow(0 0 22px rgba(255,0,0,0.70));
  animation: badgeSelectedPulse 1.35s ease-in-out infinite;
}

.leaflet-marker-icon.badge-alert .club-badge-inner{
  animation:
    badgeAlertScale 0.90s ease-in-out infinite,
    badgeAlertPulse 0.90s ease-in-out infinite;
}

.leaflet-marker-icon.badge-selected.badge-alert .club-badge-inner{
  animation:
    badgeSelectedPulseAlert 1.10s ease-in-out infinite,
    badgeAlertPulse 0.90s ease-in-out infinite;
}

/* ===== STADIUM RENDER MARKERS (Optional Overlay) ===== */
.leaflet-marker-icon.stadium-render{
  background: transparent;
  border: none;
}

.leaflet-marker-icon.stadium-render .stadium-inner{
  width: 100%;
  height: 100%;
  border-radius: 14px;
  overflow: hidden;
  transform-origin: 50% 50%;
}

.leaflet-marker-icon.stadium-render .stadium-img{
  width: 100%;
  height: 100%;
  display: block;
  object-fit: contain;
}

.leaflet-marker-icon.stadium-render.badge-selected .stadium-inner{
  filter:
    drop-shadow(0 0 10px rgba(255,0,0,0.95))
    drop-shadow(0 0 22px rgba(255,0,0,0.70));
  animation: badgeSelectedPulse 1.35s ease-in-out infinite;
}

.leaflet-marker-icon.stadium-render.badge-alert .stadium-inner{
  animation:
    badgeAlertScale 0.90s ease-in-out infinite,
    badgeAlertPulse 0.90s ease-in-out infinite;
}

.leaflet-marker-icon.stadium-render.badge-selected.badge-alert .stadium-inner{
  animation:
    badgeSelectedPulseAlert 1.10s ease-in-out infinite,
    badgeAlertPulse 0.90s ease-in-out infinite;
}

/* ===== 3D STADIUM CANVAS OVERLAY (Option C) ===== */
.three-stadium-canvas{
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 600; /* above tiles/markers; selected badges still use z-index offsets */
}

/* ===== FIXTURE TRAVEL (Away -> Home) ===== */
.fixture-trail{
  filter: drop-shadow(0 0 4px rgba(255,0,255,0.75));
}

.fixture-trail-return{
  filter: drop-shadow(0 0 4px rgba(0,255,255,0.75));
}

/* ===== FIXTURE INFO (mini scoreboard overlay) ===== */
.fixture-info-icon .fixture-info-box{
  cursor: pointer;
  transition:
    opacity 180ms ease,
    transform 180ms ease,
    filter 180ms ease,
    border-color 180ms ease,
    box-shadow 180ms ease;
}

.fixture-info-icon.fixture-faded .fixture-info-box{
  opacity: 0.16;
  transform: translateY(2px) scale(0.985);
  filter: saturate(0.80) brightness(0.90);
}

.fixture-info-icon.fixture-faded:hover .fixture-info-box{
  opacity: 1;
  transform: translateY(0) scale(1.0);
  filter: none;
}

.fixture-info-icon.fixture-active .fixture-info-box{
  opacity: 1;
  transform: none;
  filter: none;
}

.fixture-info-box{
  background: linear-gradient(180deg, rgba(0,0,0,0.86), rgba(0,0,0,0.66));
  border: 1px solid rgba(0,255,0,0.32);
  box-shadow: 0 0 22px rgba(0,255,0,0.10);
  border-radius: 12px;
  padding: 10px 12px;
  color: var(--white);
  font-family: Teletext, monospace;
  line-height: 1.15;
  max-width: 260px;
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}

.fixture-info-box:hover{
  border-color: rgba(0,255,0,0.55);
  box-shadow: 0 0 26px rgba(0,255,0,0.16);
}

.fx-mini-main{
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  align-items: center;
  gap: 10px;
}

.fx-mini-team{
  display: flex;
  align-items: center;
  gap: 8px;
  min-width: 0;
}

.fx-mini-team.right{ justify-content: flex-end; }

.fx-mini-crest{
  width: 30px;
  height: 30px;
  object-fit: contain;
  image-rendering: crisp-edges;
  filter: drop-shadow(0 0 8px rgba(0,0,0,0.55));
}

.fx-mini-name{
  font-size: 14px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.fx-mini-score{
  display: flex;
  align-items: center;
  gap: 8px;
}

.fx-mini-score-num{
  color: var(--yellow);
  font-size: 26px;
  line-height: 1;
}

.fx-mini-score-sep{
  width: 2px;
  height: 26px;
  background: rgba(0,255,0,0.35);
}

.fx-mini-meta{
  margin-top: 6px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  color: var(--cyan);
  font-size: 12px;
  opacity: 0.95;
}

.fx-mini-status{
  color: var(--green);
  white-space: nowrap;
  padding: 2px 6px;
  border-radius: 999px;
  border: 1px solid rgba(0,255,0,0.28);
  background: rgba(0,0,0,0.35);
}

/* ===== MATCH SCOREBOARD (top overlay) ===== */
.match-scoreboard{
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  width: min(980px, calc(100% - 24px));
  top: 12px;
  z-index: 12000;
  pointer-events: none;
}

.match-scoreboard-inner{
  pointer-events: auto;
  max-width: 760px;
  margin: 0 auto;
  background: linear-gradient(180deg, rgba(0,0,0,0.88), rgba(0,0,0,0.70));
  border: 1px solid rgba(0,255,0,0.35);
  box-shadow: 0 0 22px rgba(0,255,0,0.12);
  border-radius: 12px;
  padding: 10px 12px;
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}

.match-scoreboard-top{
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}

.match-scoreboard-meta{
  color: var(--cyan);
  font-size: 12px;
  opacity: 0.95;
}

.match-scoreboard-close{
  background: transparent;
  color: var(--cyan);
  border: 1px solid rgba(0,255,0,0.35);
  border-radius: 10px;
  padding: 6px 10px;
  cursor: pointer;
  font-family: Teletext, monospace;
  font-size: 12px;
}
.match-scoreboard-close:hover{ color: var(--white); }

.match-scoreboard-main{
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  align-items: center;
  gap: 12px;
  margin-top: 8px;
}

.ms-team{
  display: flex;
  align-items: center;
  gap: 12px;
  min-width: 0;
}

.ms-team.right{ justify-content: flex-end; }

.ms-crest{
  width: 36px;
  height: 36px;
  object-fit: contain;
  image-rendering: crisp-edges;
  filter: drop-shadow(0 0 8px rgba(0,0,0,0.55));
}

.ms-name{
  color: var(--white);
  font-size: 16px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.ms-score{
  display: flex;
  align-items: center;
  gap: 12px;
}

.ms-score-num{
  color: var(--yellow);
  font-size: 34px;
  line-height: 1;
}

.ms-score-sep{
  width: 2px;
  height: 34px;
  background: rgba(0,255,0,0.35);
}

.ms-status{
  margin-top: 6px;
  text-align: center;
  color: var(--green);
  font-size: 14px;
  display: inline-block;
  padding: 2px 10px;
  border-radius: 999px;
  border: 1px solid rgba(0,255,0,0.28);
  background: rgba(0,0,0,0.35);
}

.ms-sub{
  margin-top: 6px;
  color: var(--cyan);
  font-size: 12px;
  text-align: center;
}

@media (max-width: 768px) {
  .match-scoreboard{
    top: 8px;
    width: calc(100% - 16px);
  }
  .match-scoreboard-inner{
    padding: 10px 10px;
  }
  .ms-crest{
    width: 34px;
    height: 34px;
  }
  .ms-name{
    font-size: 16px;
  }
  .ms-score-num{
    font-size: 34px;
  }
  .ms-score-sep{
    height: 34px;
  }
}

/* Compact overlay mode (top scoreboard + fixture boxes) */
.compact-overlays .match-scoreboard-inner{ max-width: 640px; padding: 8px 10px; }
.compact-overlays .ms-crest{ width: 30px; height: 30px; }
.compact-overlays .ms-name{ font-size: 14px; }
.compact-overlays .ms-score-num{ font-size: 30px; }
.compact-overlays .ms-score-sep{ height: 30px; }
.compact-overlays .ms-status{ font-size: 12px; margin-top: 4px; }
.compact-overlays .ms-sub{ display: none; }

.compact-overlays .fixture-info-box{ padding: 8px 10px; max-width: 240px; }
.compact-overlays .fx-mini-crest{ width: 26px; height: 26px; }
.compact-overlays .fx-mini-name{ font-size: 13px; }
.compact-overlays .fx-mini-score-num{ font-size: 24px; }
.compact-overlays .fx-mini-score-sep{ height: 24px; }
.compact-overlays .fx-mini-meta{ font-size: 11px; }

@media (max-width: 768px){
  .ms-name{ font-size: 16px; }
  .ms-score-num{ font-size: 34px; }
  .ms-crest{ width: 36px; height: 36px; }
}

/* Keep fixture info above most map content */
.leaflet-fixtureInfoPane-pane{
  z-index: 650;
}

.fixture-info-icon{
  background: transparent;
  border: none;
}

@media (prefers-reduced-motion: reduce) {
  .leaflet-marker-icon.badge-selected,
  .leaflet-marker-icon.badge-alert,
  .leaflet-marker-icon.map-highlight,
  .leaflet-marker-icon.bounce-highlight,
  .leaflet-marker-icon.pulse {
    animation: none !important;
  }

  .leaflet-marker-icon.badge-selected .club-badge-inner,
  .leaflet-marker-icon.badge-alert .club-badge-inner {
    animation: none !important;
  }
}


</style>

</head>

<body>
<h1>UK FOOTBALL TRANSFER SITUATION — LIVE</h1>

<div id="container">
  <div id="map"></div>
  <div id="sidebar"></div>
</div>

<div id="ticker">
  <div class="scroll" id="tickerScroll">
    <a id="tickerLink" href="#" target="_blank" rel="noopener">
      <img id="tickerIcon" class="ticker-icon" src="" alt="" style="display:none;">
      <span id="tickerText">INITIALISING FOOTBALL DESK…</span>
    </a>
  </div>
</div>

<!-- Audio -->
<audio id="sndClick" preload="auto" src="sound/click.wav"></audio>
<audio id="sndBack"  preload="auto" src="sound/click_back.wav"></audio>
<audio id="sndNews"  preload="auto" src="sound/event_popup_01.wav"></audio>
<audio id="sndHelicopter" preload="auto" src="sound/sounds/helicopter_start_01.wav"></audio>
<audio id="sndBells" preload="auto" src="sound/sounds/bells_big_ben_normal_01.wav"></audio>


<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

<!-- 3D Stadium Overlay (Three.js) -->
<!-- three@0.160.0 no longer ships legacy `examples/js/*` loaders; use the module `examples/jsm/*` loaders instead. -->
<script type="importmap">
{
  "imports": {
    "three": "./vendor/three-0.160.0/three.module.js",
    "three/addons/": "./vendor/three-0.160.0/addons/"
  }
}
</script>

<script type="module">
// Load Three.js + GLTFLoader as ES modules, but never let failures break the app.
// If this fails, the 3D overlay will be disabled, but the rest of the UI should still work.
(async () => {
  try {
    const THREE = await import("three");
    // Expose Three immediately; loader is added next.
    window.THREE = Object.assign({}, THREE);
    const mod = await import("three/addons/loaders/GLTFLoader.js");
    const GLTFLoader = mod && (mod.GLTFLoader || mod.default);
    window.THREE = Object.assign({}, THREE, { GLTFLoader });
    window.dispatchEvent(new Event('three-ready'));
  } catch (e) {
    console.warn("Three.js modules failed to load; 3D disabled", e);
  }
})();
</script>

<script>
// Ensure toast container exists before any toasts fire.
(function(){
  if(document.getElementById('toast-container')) return;
  const el = document.createElement('div');
  el.id = 'toast-container';
  el.style.position = 'fixed';
  el.style.bottom = '20px';
  el.style.right = '20px';
  el.style.zIndex = '99999';
  el.style.display = 'flex';
  el.style.flexDirection = 'column';
  el.style.gap = '10px';
  document.addEventListener('DOMContentLoaded', () => document.body.appendChild(el));
})();

// Match scoreboard overlay (top-of-map)
(function(){
  function ensure(){
    if(document.getElementById('match-scoreboard')) return;
    const wrap = document.createElement('div');
    wrap.id = 'match-scoreboard';
    wrap.className = 'match-scoreboard';
    wrap.style.display = 'none';
    wrap.innerHTML = `
      <div class="match-scoreboard-inner">
        <div class="match-scoreboard-top">
          <div class="match-scoreboard-meta" id="ms-meta">—</div>
          <button class="match-scoreboard-close" id="ms-close">Close</button>
        </div>
        <div class="match-scoreboard-main">
          <div class="ms-team left">
            <img class="ms-crest" id="ms-home-crest" alt="">
            <div class="ms-name" id="ms-home-name">Home</div>
          </div>
          <div>
            <div class="ms-score">
              <div class="ms-score-num" id="ms-home-score">—</div>
              <div class="ms-score-sep"></div>
              <div class="ms-score-num" id="ms-away-score">—</div>
            </div>
            <div class="ms-status" id="ms-status">Status: —</div>
            <div class="ms-sub" id="ms-sub">—</div>
          </div>
          <div class="ms-team right">
            <div class="ms-name" id="ms-away-name">Away</div>
            <img class="ms-crest" id="ms-away-crest" alt="">
          </div>
        </div>
      </div>
    `;
    document.addEventListener('DOMContentLoaded', () => {
      const mapEl = document.getElementById('map');
      if(mapEl){
        mapEl.style.position = mapEl.style.position || 'relative';
        mapEl.appendChild(wrap);
      } else {
        document.body.appendChild(wrap);
      }

      const btn = document.getElementById('ms-close');
      if(btn){
        btn.addEventListener('click', () => {
          try{ window.__activeFixtureKey = null; } catch {}
          try{
            showMatchScoreboard = false;
            localStorage.setItem("showMatchScoreboard", "off");
            const cb = document.getElementById('cbMatchScoreboard');
            if(cb) cb.checked = false;
          } catch {}
          wrap.style.display = 'none';
        });
      }

      try{ applyOverlayUiMode(); } catch {}
    });
  }
  ensure();
})();

// Basic on-screen crash reporter (helps when DevTools isn't available).
(function(){
  const box = document.createElement('div');
  box.id = 'errorBox';
  box.style.cssText = 'position:fixed;left:10px;right:10px;bottom:10px;max-height:40vh;overflow:auto;z-index:999999;background:rgba(0,0,0,0.92);border:1px solid #f00;color:#ff0;font-family:Teletext, monospace;font-size:12px;padding:8px;display:none;white-space:pre-wrap;';
  document.addEventListener('DOMContentLoaded', () => document.body.appendChild(box));
  function show(msg){
    try{
      box.style.display = 'block';
      box.textContent += (box.textContent ? '\n\n' : '') + msg;
    } catch {}
  }
  window.addEventListener('error', (ev) => {
    const m = ev && ev.message ? ev.message : 'Script error';
    const where = (ev && ev.filename) ? `\n${ev.filename}:${ev.lineno || 0}:${ev.colno || 0}` : '';
    show(`ERROR: ${m}${where}`);
  });
  window.addEventListener('unhandledrejection', (ev) => {
    const r = ev && ev.reason ? (ev.reason.stack || String(ev.reason)) : 'unknown';
    show(`PROMISE: ${r}`);
  });
})();

/* ===================== CONFIG ===================== */
// Temporary kill-switch while stadium overlays are being fixed.
const DISABLE_STADIUM_OVERLAYS = true;

const COUNTRY_NAMES = {
  ENG: "England",
  SCO: "Scotland",
  WAL: "Wales",
  NIR: "Northern Ireland",
  IRL: "Republic of Ireland"
};

const LEAGUE_ORDER = {
  "England": [
    "FA Premier League",
    "Division One",
    "Division Two",
    "Division Three",
  ],
  "Scotland": [
    "Scottish Premier Division",
    "Scottish First Division",
    "Scottish Second Division",
    "Scottish Third Division"
  ],
  "Wales": [
    "League of Wales"
  ],
  "Northern Ireland": [
    "Irish League Premier Division"
  ],
  "Republic of Ireland": [
    "League of Ireland Premier Division",
    "League of Ireland First Division"
  ]
};

const FEED_ICONS = {
  "BBC": "ticker_icons/BBC.png",
  "Sky": "ticker_icons/Sky.png",
  "Guardian": "ticker_icons/Guardian.png",
  "Football365": "ticker_icons/Football365.png",
  "Goal": "ticker_icons/Goal.png",
  "Romano": "ticker_icons/Romano.jpg",

  // Noise pack
  "CaughtOffside": "ticker_icons/caughtoffside.png",
  "TEAMtalk": "ticker_icons/TEAMtalk.png",
  "SportsLens": "ticker_icons/sportslens.jpg",
  "101GreatGoals": "ticker_icons/101GreatGoals.jpg",
  "90min": "ticker_icons/90min.jpg",
  "SoccerNews": "ticker_icons/SoccerNews.jpg",
  "FootballFanCast": "ticker_icons/FootballFanCast.jpg",
  "FourFourTwo": "ticker_icons/FourFourTwo.png",
  "The72": "ticker_icons/The72.png",
  "HITC": "ticker_icons/HITC.png",
  "FootballTalk": "ticker_icons/FootballTalk.jpg",
  "MetroFootball": "ticker_icons/MetroFootball.jpg",
  "EveningStandardFootball": "ticker_icons/EveningStandardFootball.png",
  "IndependentFootball": "ticker_icons/IndependentFootball.png",
  "iNewsFootball": "ticker_icons/iNewsFootball.png",
  "DailyMailFootball": "ticker_icons/DailyMailFootball.png",
  "MirrorFootball": "ticker_icons/MirrorFootball.png",
  "ThisIsAnfield": "ticker_icons/ThisIsAnfield.jpg",
  "@bristolcity": "ticker_icons/bristolcity.jpg",
  "RedditSoccer": "ticker_icons/RedditSoccer.png"
};

/**
 * Feeds:
 * - Your originals
 * - Romano (rss.app)
 * - “FeedSpot noise pack” (starter set)
 *
 * If you want to go fully insane with sources:
 * just keep adding ["Label","RSS_URL"] here.
 */
const FEEDS = [
  ["BBC", "https://feeds.bbci.co.uk/sport/football/rss.xml"],
  ["Sky", "https://www.skysports.com/rss/12040"],
  ["Guardian", "https://www.theguardian.com/football/rss"],
  ["Football365", "https://www.football365.com/rss"],
  ["Goal", "https://www.goal.com/en/feeds/news?fmt=rss"],
  ["Romano", "https://rss.app/feeds/Rbu1YfkhckMTuUZW.xml"],
  ["@bristolcity", "https://rss.app/feeds/CoJAjLdj6kFSAaBE.xml"],

  // Noise pack
  ["CaughtOffside", "https://caughtoffside.com/feed/"],
  ["TEAMtalk", "https://www.teamtalk.com/feed"],
  ["SportsLens", "https://sportslens.com/feed/"],
  ["101GreatGoals", "https://www.101greatgoals.com/feed/"],
  ["90min", "https://www.90min.com/posts.rss"],
  ["SoccerNews", "https://www.soccernews.com/feed/"],
  ["FootballFanCast", "https://www.footballfancast.com/feed/"],
  ["FourFourTwo", "https://www.fourfourtwo.com/rss"],
  ["The72", "https://the72.co.uk/feed/"],
  ["HITC", "https://www.hitc.com/en-gb/category/football/feed/"],
  ["FootballTalk", "https://football-talk.co.uk/feed/"],
  ["MetroFootball", "https://metro.co.uk/tag/football/feed/"],
  ["EveningStandardFootball", "https://www.standard.co.uk/sport/football/rss"],
  ["IndependentFootball", "https://www.independent.co.uk/sport/football/rss"],
  ["iNewsFootball", "https://inews.co.uk/sport/football/feed"],
  ["DailyMailFootball", "https://www.dailymail.co.uk/sport/football/index.rss"],
  ["MirrorFootball", "https://www.mirror.co.uk/sport/football/rss.xml"],
  ["ThisIsAnfield", "https://www.thisisanfield.com/feed/"],
  ["RedditSoccer", "https://www.reddit.com/r/soccer/.rss"]
];

const POLL_EVERY_MS = 25000;
const FEEDS_PER_TICK = 8;          // rotate through feeds to avoid rate limits
const MAX_ITEMS_PER_FEED = 10;
const MAX_RUMOURS_PER_CLUB = 25;
const AUTO_BACK_TIMEOUT_MS = 30000;

const STADIUM_MIN_ZOOM = 10;
const STADIUM_ICON_SIZE = 140;

const STADIUM3D_MIN_ZOOM = 12;
const STADIUM3D_DEFAULT_SCALE = 18;

const FIXTURES_URL = "fixtures.json"; // optional; provide a real fixtures feed by generating this file daily
const SCORES_URL = "scores.json";     // optional; live scoreboard feed (you can generate this)
const FIXTURE_TRAVEL_MIN_ZOOM = 6;
const FIXTURE_TRAVEL_HOURS_BEFORE_KO = 5;
const FIXTURE_MATCH_DURATION_HOURS = 2.1;          // ~126 mins (HT + stoppage buffer)
const FIXTURE_RETURN_DURATION_HOURS = 2.5;         // return journey duration
const FIXTURE_TRAVEL_TICK_MS = 250; // marker update cadence while travelling
const FIXTURE_TRAIL_SAMPLE_MS = 450; // add a trail point at most this often
// Keep home+away badges visually separated at the opponent ground.
// Pixel-based so it stays readable at any zoom.
const FIXTURE_PARK_RADIUS_PX_MIN = 72;
const FIXTURE_PARK_RADIUS_PX_MAX = 126;
const FIXTURE_LABEL_OFFSET_Y_PX = 64;
const SCORE_POLL_EVERY_MS = 20000;

const FIXTURE_INFO_BOX_W_PX = 260;
const FIXTURE_INFO_BOX_H_PX = 92; // rough; used only for placement heuristics
const FIXTURE_INFO_EDGE_PAD_PX = 18;

// Below this zoom, fixture mini-scoreboards fade out (hover/click brings them back).
const FIXTURE_INFO_FADE_BELOW_ZOOM = 8;

const CLUB_ICON_SIZE = 84;

/* ===================== STATE ===================== */
const sidebar = document.getElementById("sidebar");
const tickerTextEl = document.getElementById("tickerText");
const tickerLinkEl = document.getElementById("tickerLink");
const tickerIconEl = document.getElementById("tickerIcon");

/* ===================== STATE ===================== */
// ...
const sndNews  = document.getElementById("sndNews");
const sndHelicopter = document.getElementById("sndHelicopter");
const sndBells = document.getElementById("sndBells");

const clubMarkers = new Map(); // ✅ KEEP this one
const stadiumMarkers = new Map();
const stadiumLayer = L.layerGroup();

let stadiums3dByClubId = {};
let showStadiums3d = (localStorage.getItem("showStadiums3d") || "off") === "on";
let stadium3dLayer = null;

let fixturesToday = [];
let showFixtureTravel = (localStorage.getItem("showFixtureTravel") || "off") === "on";
let fixtureTravelLayer = L.layerGroup();
let fixtureTravelStatus = { total: 0, resolved: 0, active: 0, lastLoad: null, lastError: null };
const fixtureTravelActiveByAwayId = new Map();
let _fixtureTravelTimer = null;

// Overlay boxes are optional; default off now that we have a top scoreboard.
let showFixtureInfo = (localStorage.getItem("showFixtureInfo") || "off") === "on";
let fixtureInfoLayer = L.layerGroup();
const fixtureInfoMarkers = new Map();
let liveScoresByKey = new Map();
let _scorePollTimer = null;
let _scoresInitialized = false;

let showMatchScoreboard = (localStorage.getItem("showMatchScoreboard") || "on") === "on";
window.__activeFixtureKey = null;

let compactOverlays = (localStorage.getItem("compactOverlays") || "on") === "on";

let _apiHealthTimer = null;

// If the top scoreboard is on, keep the map clean by default.
if(showMatchScoreboard && showFixtureInfo){
  showFixtureInfo = false;
  try{ localStorage.setItem("showFixtureInfo", "off"); } catch {}
}

function applyOverlayUiMode(){
  try{
    const mapEl = document.getElementById('map');
    if(!mapEl) return;
    mapEl.classList.toggle('compact-overlays', !!compactOverlays);
  } catch {}
}
applyOverlayUiMode();

async function checkLocalApiHealth({ silent = true } = {}){
  const el = document.getElementById('apiStatus');
  if(!el) return;

  const set = (color, text) => {
    el.style.color = color;
    el.textContent = text;
  };

  try{
    set('var(--cyan)', 'API: checking…');
    const resp = await fetch('/api/health', { method: 'GET', cache: 'no-store' });
    const data = await resp.json().catch(() => null);
    if(!resp.ok || !data || data.ok !== true){
      set('var(--red)', 'API: unavailable (run python server.py)');
      return;
    }
    if(data.tokenPresent){
      set('var(--green)', 'API: OK (token present)');
    } else {
      set('var(--yellow)', 'API: OK (set FOOTBALL_DATA_TOKEN)');
      if(!silent) toast('Token missing. Set env var FOOTBALL_DATA_TOKEN then restart the server.');
    }
  } catch {
    set('var(--red)', 'API: unavailable (run python server.py)');
  }
}

let _clubAliasToId = new Map();
let _clubById = new Map();

let selectedClubId = null;
const markerAlertTimeouts = new Map();

let stadiumsByClubId = {};
let showStadiums = (localStorage.getItem("showStadiums") || "off") === "on";
let customStadiumsByClubId = {};

if(DISABLE_STADIUM_OVERLAYS){
  showStadiums = false;
  showStadiums3d = false;
  try{ localStorage.setItem("showStadiums", "off"); } catch {}
  try{ localStorage.setItem("showStadiums3d", "off"); } catch {}
}

let clubs = [];
// ...

let rumoursByClub = new Map();
let seenKeys = new Set();
let unreadCounts = {};

let openCountries = new Set();
let openLeagues = new Set();
let userClosedCountries = new Set();
let userClosedLeagues = new Set();

let viewClubId = null;
let viewTimeout = null;

let feedIndex = 0;

/* ===================== MAP ===================== */
const map = L.map("map");

// Restore saved zoom and center if available
const savedCenter = localStorage.getItem("mapCenter");
const savedZoom = localStorage.getItem("mapZoom");

if (savedCenter && savedZoom) {
  const [lat, lng] = JSON.parse(savedCenter);
  map.setView([lat, lng], parseInt(savedZoom));
} else {
  map.setView([53, -2.5], 6); // fallback to default UK view
}

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  attribution: "© OpenStreetMap"
}).addTo(map);

// Pane for fixture info overlays (scoreboxes). Keeps them readable above the map.
try{
  if(!map.getPane('fixtureInfoPane')){
    map.createPane('fixtureInfoPane');
  }
} catch {}
// Save zoom and position when the map is moved or zoomed
map.on("moveend", () => {
  const center = map.getCenter();
  const zoom = map.getZoom();
  localStorage.setItem("mapCenter", JSON.stringify([center.lat, center.lng]));
  localStorage.setItem("mapZoom", zoom);
});

function clubIcon(club){
  if(!club.logo) return null;
  const url = `${club.logo}?v=${Date.now()}`;
  return L.divIcon({
    html: `<div class="club-badge-inner"><img class="club-badge-img" src="${url}" alt=""></div>`,
    className: "leaflet-div-icon club-badge",
    iconSize: [CLUB_ICON_SIZE, CLUB_ICON_SIZE],
    iconAnchor: [CLUB_ICON_SIZE/2, CLUB_ICON_SIZE/2]
  });
}

function stadiumIcon(imgPath){
  const safePath = (imgPath || "").replace(/"/g, "&quot;");
  return L.divIcon({
    html: `<div class="stadium-inner"><img class="stadium-img" src="${safePath}" alt=""></div>`,
    className: "leaflet-div-icon stadium-render",
    iconSize: [STADIUM_ICON_SIZE, STADIUM_ICON_SIZE],
    iconAnchor: [STADIUM_ICON_SIZE/2, STADIUM_ICON_SIZE/2]
  });
}

function loadCustomStadiums(){
  try{
    const raw = localStorage.getItem("customStadiums");
    customStadiumsByClubId = raw ? JSON.parse(raw) : {};
  } catch {
    customStadiumsByClubId = {};
  }
}

function saveCustomStadium(clubId, dataUrl){
  if(!clubId) return;
  customStadiumsByClubId[String(clubId)] = dataUrl;
  try{
    localStorage.setItem("customStadiums", JSON.stringify(customStadiumsByClubId));
  } catch {
    // ignore quota errors
  }
}

/* ===================== 3D STADIUM OVERLAY (Option C) ===================== */
function ensureThreeAvailable(){
  const T = (typeof window !== 'undefined') ? window.THREE : (typeof THREE !== 'undefined' ? THREE : undefined);
  return (
    typeof T !== "undefined" &&
    T &&
    typeof T.Scene === "function" &&
    typeof T.WebGLRenderer === "function" &&
    typeof T.GLTFLoader === "function"
  );
}

function updateOverlayStatus(){
  try{
    const el = document.getElementById('overlayStatus');
    if(!el) return;

    const mapped2d = stadiumsByClubId ? Object.keys(stadiumsByClubId).length : 0;
    const mapped3d = stadiums3dByClubId ? Object.keys(stadiums3dByClubId).length : 0;
    const threeOk = ensureThreeAvailable();
    const zoomNow = (typeof map !== "undefined" && map && typeof map.getZoom === "function") ? map.getZoom() : null;

    const fxTotal = fixtureTravelStatus && typeof fixtureTravelStatus.total === 'number' ? fixtureTravelStatus.total : 0;
    const fxResolved = fixtureTravelStatus && typeof fixtureTravelStatus.resolved === 'number' ? fixtureTravelStatus.resolved : 0;
    const fxActive = fixtureTravelStatus && typeof fixtureTravelStatus.active === 'number' ? fixtureTravelStatus.active : 0;

    if(DISABLE_STADIUM_OVERLAYS){
      el.innerHTML = `
        <div style="color:var(--yellow)">Fixtures today: <span style="color:var(--white)">${fxTotal}</span> (matched: ${fxResolved}, travelling: ${fxActive})</div>
        <div style="color:var(--cyan)">Map zoom: <span style="color:var(--white)">${zoomNow === null ? '—' : zoomNow}</span></div>
      `;
    } else {
      el.innerHTML = `
        <div style="color:var(--cyan)">2D mapped: <span style="color:var(--white)">${mapped2d}</span> (needs stadiums.json or preview upload)</div>
        <div style="color:var(--magenta)">3D mapped: <span style="color:var(--white)">${mapped3d}</span> (only mapped clubs will show)</div>
        <div style="color:var(--yellow)">Fixtures today: <span style="color:var(--white)">${fxTotal}</span> (matched: ${fxResolved}, travelling: ${fxActive})</div>
        <div style="color:${threeOk ? 'var(--green)' : 'var(--red)'}">3D engine: ${threeOk ? 'OK' : 'MISSING (Three.js/GLTFLoader not loaded)'}</div>
        <div style="color:var(--cyan)">Map zoom: <span style="color:var(--white)">${zoomNow === null ? '—' : zoomNow}</span> (needs ${STADIUM3D_MIN_ZOOM}+ for 3D)</div>
      `;
    }
  } catch {}
}

window.addEventListener('three-ready', () => {
  updateOverlayStatus();
  if(stadium3dLayer) stadium3dLayer._requestRender?.();
});

function parseVec3Degrees(arr){
  if(!Array.isArray(arr) || arr.length < 3) return null;
  return {
    x: (arr[0] || 0) * Math.PI / 180,
    y: (arr[1] || 0) * Math.PI / 180,
    z: (arr[2] || 0) * Math.PI / 180
  };
}

class ThreeStadiumLayer extends L.Layer {
  constructor(){
    super();
    this._canvas = null;
    this._renderer = null;
    this._scene = null;
    this._camera = null;
    this._loader = null;
    this._clubsById = new Map();
    this._modelsByClubId = new Map();
    this._pendingLoads = new Map();
    this._raf = null;
  }

  onAdd(map){
    this._map = map;
    const size = map.getSize();

    this._canvas = L.DomUtil.create("canvas", "three-stadium-canvas");
    const pane = map.getPanes().overlayPane;
    pane.appendChild(this._canvas);

    this._renderer = new THREE.WebGLRenderer({ canvas: this._canvas, alpha: true, antialias: true, preserveDrawingBuffer: false });
    this._renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    this._renderer.setSize(size.x, size.y, false);

    this._scene = new THREE.Scene();
    this._camera = new THREE.OrthographicCamera(0, size.x, 0, -size.y, -2000, 2000);
    this._camera.position.set(0, 0, 1000);
    this._camera.lookAt(new THREE.Vector3(0, 0, 0));

    const amb = new THREE.AmbientLight(0xffffff, 0.85);
    this._scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 0.75);
    dir.position.set(300, -200, 600);
    this._scene.add(dir);

    this._loader = new THREE.GLTFLoader();

    this._onMove = () => this._requestRender();
    map.on("move", this._onMove);
    map.on("zoom", this._onMove);
    map.on("resize", this._onResize.bind(this));

    this._requestRender();
  }

  onRemove(map){
    map.off("move", this._onMove);
    map.off("zoom", this._onMove);
    map.off("resize", this._onResize.bind(this));

    if(this._raf) cancelAnimationFrame(this._raf);
    this._raf = null;

    if(this._canvas && this._canvas.parentNode) this._canvas.parentNode.removeChild(this._canvas);
    this._canvas = null;

    if(this._renderer){
      try{ this._renderer.dispose(); } catch {}
    }
    this._renderer = null;
    this._scene = null;
    this._camera = null;
    this._loader = null;
    this._modelsByClubId.clear();
    this._pendingLoads.clear();
    this._clubsById.clear();
  }

  _onResize(){
    if(!this._map || !this._renderer || !this._camera) return;
    const size = this._map.getSize();
    this._renderer.setSize(size.x, size.y, false);
    this._camera.right = size.x;
    this._camera.bottom = -size.y;
    this._camera.updateProjectionMatrix();
    this._requestRender();
  }

  setData(clubs, mapping){
    this._clubsById.clear();
    (clubs || []).forEach(c => this._clubsById.set(String(c.id), c));
    this._mapping = mapping || {};
    this._requestLoadAll();
    this._requestRender();
  }

  setClubState(clubId, state){
    const id = String(clubId);
    const obj = this._modelsByClubId.get(id);
    if(!obj) return;

    const selected = !!(state && state.selected);
    const alert = !!(state && state.alert);

    const base = obj.userData.baseScale || STADIUM3D_DEFAULT_SCALE;
    let mult = 1;
    if(selected && alert) mult = 1.35;
    else if(alert) mult = 1.45;
    else if(selected) mult = 1.18;

    obj.scale.setScalar(base * mult);
    obj.renderOrder = (selected && alert) ? 12000 : alert ? 10000 : selected ? 8000 : 0;
    this._requestRender();
  }

  _requestLoadAll(){
    if(!this._loader || !this._scene) return;
    const mapping = this._mapping || {};
    for(const clubId of Object.keys(mapping)){
      this._ensureModelLoaded(String(clubId), mapping[clubId]);
    }
  }

  _ensureModelLoaded(clubId, cfg){
    if(this._modelsByClubId.has(clubId)) return;
    if(this._pendingLoads.has(clubId)) return;

    const url = (cfg && cfg.url) ? String(cfg.url) : null;
    if(!url) return;

    const loadPromise = new Promise((resolve) => {
      this._loader.load(
        url,
        (gltf) => {
          const root = gltf.scene || gltf.scenes && gltf.scenes[0];
          if(!root){ resolve(null); return; }

          root.traverse((n) => {
            if(n && n.isMesh){
              n.frustumCulled = false;
            }
          });

          const baseScale = (cfg && typeof cfg.scale === "number") ? cfg.scale : STADIUM3D_DEFAULT_SCALE;
          root.userData.baseScale = baseScale;
          root.scale.setScalar(baseScale);

          const rot = parseVec3Degrees(cfg && cfg.rotationDeg);
          if(rot){ root.rotation.set(rot.x, rot.y, rot.z); }
          else {
            // default: a slightly isometric tilt
            root.rotation.set(-0.85, 0.75, 0);
          }

          root.userData.yOffsetPx = (cfg && typeof cfg.yOffsetPx === "number") ? cfg.yOffsetPx : 0;
          root.userData.anchor = (cfg && cfg.anchor) ? cfg.anchor : "center";

          this._scene.add(root);
          this._modelsByClubId.set(clubId, root);
          this._pendingLoads.delete(clubId);
          this._requestRender();
          resolve(root);
        },
        undefined,
        (err) => {
          try{
            console.warn("3D stadium GLB load failed", { clubId, url, err });
            const box = document.getElementById('errorBox');
            if(box){
              box.style.display = 'block';
              box.textContent += (box.textContent ? '\n\n' : '') + `3D GLB FAILED: clubId=${clubId}\n${url}`;
            }
          } catch {}
          this._pendingLoads.delete(clubId);
          resolve(null);
        }
      );
    });

    this._pendingLoads.set(clubId, loadPromise);
  }

  _requestRender(){
    if(this._raf) return;
    this._raf = requestAnimationFrame(() => {
      this._raf = null;
      this._render();
    });
  }

  _render(){
    if(!this._map || !this._renderer || !this._scene || !this._camera) return;

    // show/hide based on zoom + toggle
    const visible = showStadiums3d && this._map.getZoom() >= STADIUM3D_MIN_ZOOM;
    if(this._canvas) this._canvas.style.display = visible ? "" : "none";
    if(!visible) return;

    for(const [clubId, obj] of this._modelsByClubId.entries()){
      const club = this._clubsById.get(clubId);
      if(!club) continue;
      const pt = this._map.latLngToContainerPoint([club.lat, club.lon]);
      const yOffset = obj.userData.yOffsetPx || 0;
      obj.position.set(pt.x, -pt.y - yOffset, 0);
    }

    this._renderer.render(this._scene, this._camera);
  }
}

function getMarkerIconEl(marker){
  if(!marker) return null;
  if(typeof marker.getElement === "function") return marker.getElement();
  return marker._icon || marker._path || null;
}

function syncMarkerFrontState(marker){
  if(!marker) return;
  const el = getMarkerIconEl(marker);
  const isSelected = !!el && el.classList.contains("badge-selected");
  const isAlert = !!el && el.classList.contains("badge-alert");

  if(typeof marker.setZIndexOffset === "function"){
    let offset = 0;
    if(isSelected && isAlert) offset = 12000;
    else if(isAlert) offset = 10000;
    else if(isSelected) offset = 8000;
    marker.setZIndexOffset(offset);
  }

  if((isSelected || isAlert) && typeof marker.bringToFront === "function"){
    marker.bringToFront();
  }
}

function syncClubMarkerFrontState(clubId){
  const marker = clubMarkers.get(clubId);
  if(!marker) return;
  syncMarkerFrontState(marker);
}

function syncStadiumMarkerFrontState(clubId){
  const marker = stadiumMarkers.get(clubId);
  if(!marker) return;
  syncMarkerFrontState(marker);
}

function setSelectedClubOnMap(clubId){
  if(selectedClubId === clubId) return;

  if(selectedClubId){
    const prevMarker = clubMarkers.get(selectedClubId);
    const prevEl = getMarkerIconEl(prevMarker);
    if(prevEl){
      prevEl.classList.remove("badge-selected");
    }
    syncClubMarkerFrontState(selectedClubId);

    const prevStadium = stadiumMarkers.get(selectedClubId);
    const prevStadiumEl = getMarkerIconEl(prevStadium);
    if(prevStadiumEl){
      prevStadiumEl.classList.remove("badge-selected");
    }
    syncStadiumMarkerFrontState(selectedClubId);

    if(stadium3dLayer && typeof stadium3dLayer.setClubState === "function"){
      stadium3dLayer.setClubState(selectedClubId, { selected: false, alert: false });
    }
  }

  selectedClubId = clubId;

  const marker = clubMarkers.get(clubId);
  const el = getMarkerIconEl(marker);
  if(el){
    el.classList.add("badge-selected");
  }

  syncClubMarkerFrontState(clubId);

  const stadiumMarker = stadiumMarkers.get(clubId);
  const stadiumEl = getMarkerIconEl(stadiumMarker);
  if(stadiumEl){
    stadiumEl.classList.add("badge-selected");
  }
  syncStadiumMarkerFrontState(clubId);

  if(stadium3dLayer && typeof stadium3dLayer.setClubState === "function"){
    const isAlert = markerAlertTimeouts.has(clubId);
    stadium3dLayer.setClubState(clubId, { selected: true, alert: isAlert });
  }

  // If this club has a fixture today, auto-select it for the scoreboard and show only its fixture overlay.
  try{
    const fx = pickBestFixtureKeyForClub(selectedClubId);
    setActiveFixtureKey(fx);
  } catch {}
  try{
    renderFixtureInfoMarkers();
    ensureFixtureInfoLayer();
    applyFixtureInfoFadeMode();
  } catch {}
}

function pickBestFixtureKeyForClub(clubId){
  if(!clubId) return null;
  const list = fixturesToday || [];
  if(!list.length) return null;
  const now = Date.now();

  const liveLike = (s) => {
    if(!s) return false;
    if(typeof s.minute === 'number') return true;
    const st = String(s.status || '').toLowerCase();
    return /live|in play|1st|2nd|half|ht|ft|aet|pens/.test(st);
  };

  let bestLive = null;
  let bestLiveMinute = -1;
  let bestUpcoming = null;
  let bestUpcomingT = Infinity;
  let bestAny = null;
  let bestAnyT = Infinity;

  for(const fx of list){
    const kickoffMs = parseFixtureKickoffMs(fx) || 0;
    const homeId = resolveClubId(fx.homeId || fx.home || (fx.homeTeam && (fx.homeTeam.id || fx.homeTeam.name)) || fx.homeTeamName);
    const awayId = resolveClubId(fx.awayId || fx.away || (fx.awayTeam && (fx.awayTeam.id || fx.awayTeam.name)) || fx.awayTeamName);
    if(!homeId || !awayId) continue;
    if(String(homeId) !== String(clubId) && String(awayId) !== String(clubId)) continue;

    const key = fixtureKeyFromParts(homeId, awayId, kickoffMs);
    const score = getScoreForFixtureKey(key) || getScoreForFixtureKey(fixtureKeyFromParts(homeId, awayId, 0));
    const t = kickoffMs || 9e15;

    if(liveLike(score)){
      const m = (score && typeof score.minute === 'number') ? score.minute : 0;
      if(m > bestLiveMinute){ bestLiveMinute = m; bestLive = key; }
      continue;
    }

    if(kickoffMs && kickoffMs >= now && t < bestUpcomingT){
      bestUpcomingT = t;
      bestUpcoming = key;
    }

    if(t < bestAnyT){ bestAnyT = t; bestAny = key; }
  }

  return bestLive || bestUpcoming || bestAny;
}

function triggerClubNewsAlertOnMap(clubId, durationMs = 6500){
  const marker = clubMarkers.get(clubId);
  const el = getMarkerIconEl(marker);
  if(el){
    el.classList.add("badge-alert");
    syncClubMarkerFrontState(clubId);
  }

  const stadiumMarker = stadiumMarkers.get(clubId);
  const stadiumEl = getMarkerIconEl(stadiumMarker);
  if(stadiumEl){
    stadiumEl.classList.add("badge-alert");
    syncStadiumMarkerFrontState(clubId);
  }

  if(stadium3dLayer && typeof stadium3dLayer.setClubState === "function"){
    const selected = String(selectedClubId) === String(clubId);
    stadium3dLayer.setClubState(clubId, { selected, alert: true });
  }

  const existing = markerAlertTimeouts.get(clubId);
  if(existing) clearTimeout(existing);

  const timeoutId = setTimeout(() => {
    const m = clubMarkers.get(clubId);
    const iconEl = getMarkerIconEl(m);
    if(iconEl){
      iconEl.classList.remove("badge-alert");
    }
    syncClubMarkerFrontState(clubId);

    const sm = stadiumMarkers.get(clubId);
    const stadiumIconEl = getMarkerIconEl(sm);
    if(stadiumIconEl){
      stadiumIconEl.classList.remove("badge-alert");
    }
    syncStadiumMarkerFrontState(clubId);

    if(stadium3dLayer && typeof stadium3dLayer.setClubState === "function"){
      const selected = String(selectedClubId) === String(clubId);
      stadium3dLayer.setClubState(clubId, { selected, alert: false });
    }
    markerAlertTimeouts.delete(clubId);
  }, durationMs);

  markerAlertTimeouts.set(clubId, timeoutId);
}
function drawMap() {
  // Clear any existing markers
  for (const marker of clubMarkers.values()) {
    map.removeLayer(marker);
  }
  clubMarkers.clear();

  clubs.forEach(c => {
    const icon = clubIcon(c);
    const marker = icon
      ? L.marker([c.lat, c.lon], { icon })
      : L.circleMarker([c.lat, c.lon], {
          radius: 5,
          color: "#00ff00",
          fillColor: "#00ff00",
          fillOpacity: 0.8
        });

    clubMarkers.set(c.id, marker);

  marker.on("click", () => {
    const ll = (marker && typeof marker.getLatLng === 'function') ? marker.getLatLng() : { lat: c.lat, lng: c.lon };
    map.flyTo([ll.lat, ll.lng], 9, { duration: 0.6 });
    showClub(c, true);
    setSelectedClubOnMap(c.id);

    const row = document.getElementById(`club-${c.id}`);
    if (row) {
      row.classList.add("pulse");
      setTimeout(() => row.classList.remove("pulse"), 1600);
    }
  });


    marker.addTo(map); // ← add marker directly to map
  });
}

function drawStadiums(){
  if(DISABLE_STADIUM_OVERLAYS){
    try{ if(map && map.hasLayer(stadiumLayer)) map.removeLayer(stadiumLayer); } catch {}
    stadiumMarkers.clear();
    stadiumLayer.clearLayers();
    return;
  }

  stadiumMarkers.clear();
  stadiumLayer.clearLayers();

  for(const c of clubs){
    const imgPath = (customStadiumsByClubId && customStadiumsByClubId[String(c.id)])
      || (stadiumsByClubId && stadiumsByClubId[c.id]);
    if(!imgPath) continue;

    const marker = L.marker([c.lat, c.lon], {
      icon: stadiumIcon(imgPath),
      interactive: false,
      keyboard: false
    });

    stadiumMarkers.set(c.id, marker);
    stadiumLayer.addLayer(marker);
  }

  updateStadiumVisibility();
}

function updateStadiumVisibility(){
  if(DISABLE_STADIUM_OVERLAYS){
    try{ if(map && map.hasLayer(stadiumLayer)) map.removeLayer(stadiumLayer); } catch {}
    return;
  }
  const shouldShow = showStadiums && map.getZoom() >= STADIUM_MIN_ZOOM;
  if(shouldShow){
    if(!map.hasLayer(stadiumLayer)) stadiumLayer.addTo(map);
  } else {
    if(map.hasLayer(stadiumLayer)) map.removeLayer(stadiumLayer);
  }
}

function addStadiumToggleControl(){
  if(DISABLE_STADIUM_OVERLAYS) return;
  const ctrl = L.control({ position: "topright" });
  ctrl.onAdd = () => {
    const div = L.DomUtil.create("div", "leaflet-bar");
    div.style.background = "rgba(0,0,0,0.80)";
    div.style.color = "var(--yellow)";
    div.style.border = "1px solid var(--green)";
    div.style.padding = "8px 10px";
    div.style.fontFamily = "Teletext, monospace";
    div.style.fontSize = "14px";
    div.style.lineHeight = "1.1";

    div.innerHTML = `
      <label style="display:flex; align-items:center; gap:8px; cursor:pointer; user-select:none;">
        <input id="stadiumToggle" type="checkbox" style="margin:0" ${showStadiums ? "checked" : ""}>
        STADIUMS (2D)
      </label>
      <div style="color:var(--cyan); margin-top:6px; font-size:12px;">Zoom ${STADIUM_MIN_ZOOM}+ to show</div>

      <label style="display:flex; align-items:center; gap:8px; cursor:pointer; user-select:none; margin-top:10px;">
        <input id="stadium3dToggle" type="checkbox" style="margin:0" ${showStadiums3d ? "checked" : ""}>
        STADIUMS (3D)
      </label>
      <div style="color:var(--cyan); margin-top:6px; font-size:12px;">Zoom ${STADIUM3D_MIN_ZOOM}+ to show</div>

      <div style="margin-top:8px; border-top:1px solid rgba(0,255,0,0.35); padding-top:8px;">
        <div style="color:var(--yellow); font-size:12px; margin-bottom:6px;">Quick preview (selected club)</div>
        <input id="stadiumFile" type="file" accept="image/*" style="width: 170px; color: var(--cyan); font-size:12px;" />
        <button id="stadiumApply" style="margin-top:6px; width:100%; background:#000; color:var(--yellow); border:1px solid var(--green); padding:6px 8px; cursor:pointer; font-family:Teletext, monospace;">
          APPLY 2D TO SELECTED
        </button>
        <div id="stadiumHint" style="color:var(--cyan); margin-top:6px; font-size:11px; max-width:180px;">Select a club, choose an image, then apply.</div>
      </div>
    `;

    L.DomEvent.disableClickPropagation(div);
    L.DomEvent.disableScrollPropagation(div);

    setTimeout(() => {
      const cb = div.querySelector("#stadiumToggle");
      if(cb){
        cb.addEventListener("change", () => {
          showStadiums = cb.checked;
          localStorage.setItem("showStadiums", showStadiums ? "on" : "off");
          updateStadiumVisibility();
        });
      }

      const cb3d = div.querySelector("#stadium3dToggle");
      if(cb3d){
        cb3d.addEventListener("change", () => {
          showStadiums3d = cb3d.checked;
          localStorage.setItem("showStadiums3d", showStadiums3d ? "on" : "off");
          if(stadium3dLayer) stadium3dLayer._requestRender?.();
        });
      }

      const fileInput = div.querySelector("#stadiumFile");
      const applyBtn = div.querySelector("#stadiumApply");
      const hint = div.querySelector("#stadiumHint");
      let pendingDataUrl = null;

      if(fileInput){
        fileInput.addEventListener("change", () => {
          const f = fileInput.files && fileInput.files[0];
          if(!f){ pendingDataUrl = null; return; }

          const reader = new FileReader();
          reader.onload = () => {
            pendingDataUrl = String(reader.result || "");
            if(hint) hint.textContent = "Image loaded. Click APPLY.";
          };
          reader.onerror = () => {
            pendingDataUrl = null;
            if(hint) hint.textContent = "Could not read file.";
          };
          reader.readAsDataURL(f);
        });
      }

      if(applyBtn){
        applyBtn.addEventListener("click", () => {
          if(!selectedClubId){
            if(hint) hint.textContent = "Select a club first (sidebar or badge).";
            return;
          }
          if(!pendingDataUrl){
            if(hint) hint.textContent = "Choose an image first.";
            return;
          }

          saveCustomStadium(selectedClubId, pendingDataUrl);
          drawStadiums();

          // auto-enable stadium overlay and zoom if needed
          showStadiums = true;
          localStorage.setItem("showStadiums", "on");
          const toggle = div.querySelector("#stadiumToggle");
          if(toggle) toggle.checked = true;

          if(map.getZoom() < STADIUM_MIN_ZOOM){
            const club = clubs.find(c => String(c.id) === String(selectedClubId));
            if(club) map.flyTo([club.lat, club.lon], STADIUM_MIN_ZOOM, { duration: 0.6 });
            else map.setZoom(STADIUM_MIN_ZOOM);
          } else {
            updateStadiumVisibility();
          }

          if(hint) hint.textContent = "Applied. Zoom in to see it.";
        });
      }
    }, 0);

    return div;
  };
  ctrl.addTo(map);
}

function createStadiumSidebarPanel(){
  const wrap = document.createElement("div");
  wrap.style.border = "1px solid rgba(0,255,0,0.55)";
  wrap.style.padding = "8px 10px";
  wrap.style.marginBottom = "12px";
  wrap.style.background = "rgba(0,0,0,0.55)";

  const title = document.createElement("div");
  title.style.color = "var(--yellow)";
  title.style.fontSize = "14px";
  title.style.marginBottom = "8px";
  title.textContent = "Map overlays";
  wrap.appendChild(title);

  let cb2d = null;
  let cb3d = null;
  if(!DISABLE_STADIUM_OVERLAYS){
    const row2d = document.createElement("label");
    row2d.style.display = "flex";
    row2d.style.alignItems = "center";
    row2d.style.gap = "8px";
    row2d.style.cursor = "pointer";
    row2d.style.userSelect = "none";
    row2d.style.color = "var(--cyan)";
    row2d.style.fontSize = "14px";

    cb2d = document.createElement("input");
    cb2d.type = "checkbox";
    cb2d.checked = !!showStadiums;
    row2d.appendChild(cb2d);
    row2d.appendChild(document.createTextNode("STADIUMS (2D)"));
    wrap.appendChild(row2d);

    const hint2d = document.createElement("div");
    hint2d.style.color = "var(--green)";
    hint2d.style.opacity = "0.9";
    hint2d.style.fontSize = "12px";
    hint2d.style.margin = "6px 0 10px";
    hint2d.textContent = `Zoom ${STADIUM_MIN_ZOOM}+ to show`;
    wrap.appendChild(hint2d);

    const row3d = document.createElement("label");
    row3d.style.display = "flex";
    row3d.style.alignItems = "center";
    row3d.style.gap = "8px";
    row3d.style.cursor = "pointer";
    row3d.style.userSelect = "none";
    row3d.style.color = "var(--magenta)";
    row3d.style.fontSize = "14px";

    cb3d = document.createElement("input");
    cb3d.type = "checkbox";
    cb3d.checked = !!showStadiums3d;
    row3d.appendChild(cb3d);
    row3d.appendChild(document.createTextNode("STADIUMS (3D)"));
    wrap.appendChild(row3d);

    const hint3d = document.createElement("div");
    hint3d.style.color = "var(--green)";
    hint3d.style.opacity = "0.9";
    hint3d.style.fontSize = "12px";
    hint3d.style.marginTop = "6px";
    hint3d.textContent = `Zoom ${STADIUM3D_MIN_ZOOM}+ to show`;
    wrap.appendChild(hint3d);
  }

  const rowFx = document.createElement("label");
  rowFx.style.display = "flex";
  rowFx.style.alignItems = "center";
  rowFx.style.gap = "8px";
  rowFx.style.cursor = "pointer";
  rowFx.style.userSelect = "none";
  rowFx.style.color = "var(--yellow)";
  rowFx.style.fontSize = "14px";
  rowFx.style.marginTop = "10px";

  const cbFx = document.createElement("input");
  cbFx.type = "checkbox";
  cbFx.checked = !!showFixtureTravel;
  rowFx.appendChild(cbFx);
  rowFx.appendChild(document.createTextNode("FIXTURES (Away travel)"));
  wrap.appendChild(rowFx);

  const hintFx = document.createElement("div");
  hintFx.style.color = "var(--cyan)";
  hintFx.style.opacity = "0.9";
  hintFx.style.fontSize = "12px";
  hintFx.style.marginTop = "6px";
  hintFx.textContent = `Uses ${FIXTURES_URL} • Zoom ${FIXTURE_TRAVEL_MIN_ZOOM}+ • Away travels to match then returns`;
  wrap.appendChild(hintFx);

  const fxBtn = document.createElement("button");
  fxBtn.textContent = "Reload fixtures";
  fxBtn.style.marginTop = "8px";
  fxBtn.style.width = "100%";
  fxBtn.style.background = "#000";
  fxBtn.style.color = "var(--cyan)";
  fxBtn.style.border = "1px solid var(--green)";
  fxBtn.style.padding = "6px 8px";
  fxBtn.style.cursor = "pointer";
  fxBtn.style.fontFamily = "Teletext, monospace";
  fxBtn.style.fontSize = "12px";
  wrap.appendChild(fxBtn);

  const fxFetchBtn = document.createElement("button");
  fxFetchBtn.textContent = "Fetch real fixtures (today)";
  fxFetchBtn.style.marginTop = "8px";
  fxFetchBtn.style.width = "100%";
  fxFetchBtn.style.background = "#000";
  fxFetchBtn.style.color = "var(--yellow)";
  fxFetchBtn.style.border = "1px solid var(--green)";
  fxFetchBtn.style.padding = "6px 8px";
  fxFetchBtn.style.cursor = "pointer";
  fxFetchBtn.style.fontFamily = "Teletext, monospace";
  fxFetchBtn.style.fontSize = "12px";
  wrap.appendChild(fxFetchBtn);

  const apiStatus = document.createElement('div');
  apiStatus.id = 'apiStatus';
  apiStatus.style.marginTop = '6px';
  apiStatus.style.fontSize = '12px';
  apiStatus.style.opacity = '0.95';
  apiStatus.style.color = 'var(--cyan)';
  apiStatus.textContent = 'API: unknown';
  wrap.appendChild(apiStatus);

  const rowFxInfo = document.createElement("label");
  rowFxInfo.style.display = "flex";
  rowFxInfo.style.alignItems = "center";
  rowFxInfo.style.gap = "8px";
  rowFxInfo.style.cursor = "pointer";
  rowFxInfo.style.userSelect = "none";
  rowFxInfo.style.color = "var(--green)";
  rowFxInfo.style.fontSize = "14px";
  rowFxInfo.style.marginTop = "10px";

  const cbFxInfo = document.createElement("input");
  cbFxInfo.type = "checkbox";
  cbFxInfo.checked = !!showFixtureInfo;
  rowFxInfo.appendChild(cbFxInfo);
  rowFxInfo.appendChild(document.createTextNode("FIXTURE INFO (overlay)"));
  wrap.appendChild(rowFxInfo);

  const rowMs = document.createElement("label");
  rowMs.style.display = "flex";
  rowMs.style.alignItems = "center";
  rowMs.style.gap = "8px";
  rowMs.style.cursor = "pointer";
  rowMs.style.userSelect = "none";
  rowMs.style.color = "var(--cyan)";
  rowMs.style.fontSize = "14px";
  rowMs.style.marginTop = "10px";

  const cbMs = document.createElement("input");
  cbMs.type = "checkbox";
  cbMs.id = 'cbMatchScoreboard';
  cbMs.checked = !!showMatchScoreboard;
  rowMs.appendChild(cbMs);
  rowMs.appendChild(document.createTextNode("MATCH SCOREBOARD (top)"));
  wrap.appendChild(rowMs);

  const rowCompact = document.createElement("label");
  rowCompact.style.display = "flex";
  rowCompact.style.alignItems = "center";
  rowCompact.style.gap = "8px";
  rowCompact.style.cursor = "pointer";
  rowCompact.style.userSelect = "none";
  rowCompact.style.color = "var(--cyan)";
  rowCompact.style.fontSize = "14px";
  rowCompact.style.marginTop = "10px";

  const cbCompact = document.createElement("input");
  cbCompact.type = "checkbox";
  cbCompact.id = 'cbCompactOverlays';
  cbCompact.checked = !!compactOverlays;
  rowCompact.appendChild(cbCompact);
  rowCompact.appendChild(document.createTextNode("COMPACT OVERLAYS"));
  wrap.appendChild(rowCompact);

  const fxTestBtn = document.createElement("button");
  fxTestBtn.textContent = "TEST: Derby @ Bristol City (fast)";
  fxTestBtn.style.marginTop = "8px";
  fxTestBtn.style.width = "100%";
  fxTestBtn.style.background = "#000";
  fxTestBtn.style.color = "var(--yellow)";
  fxTestBtn.style.border = "1px solid var(--green)";
  fxTestBtn.style.padding = "6px 8px";
  fxTestBtn.style.cursor = "pointer";
  fxTestBtn.style.fontFamily = "Teletext, monospace";
  fxTestBtn.style.fontSize = "12px";
  wrap.appendChild(fxTestBtn);

  const status = document.createElement("div");
  status.id = 'overlayStatus';
  status.style.marginTop = "10px";
  status.style.paddingTop = "8px";
  status.style.borderTop = "1px solid rgba(0,255,0,0.25)";
  status.style.fontSize = "12px";
  status.style.color = "var(--yellow)";
  wrap.appendChild(status);

  updateOverlayStatus();

  let testBtn = null;
  if(!DISABLE_STADIUM_OVERLAYS){
    testBtn = document.createElement("button");
    testBtn.textContent = "TEST: ZOOM TO 3D STADIUM";
    testBtn.style.marginTop = "8px";
    testBtn.style.width = "100%";
    testBtn.style.background = "#000";
    testBtn.style.color = "var(--yellow)";
    testBtn.style.border = "1px solid var(--green)";
    testBtn.style.padding = "6px 8px";
    testBtn.style.cursor = "pointer";
    testBtn.style.fontFamily = "Teletext, monospace";
    testBtn.style.fontSize = "12px";
    wrap.appendChild(testBtn);
  }

  if(cb2d){
    cb2d.addEventListener("change", () => {
      showStadiums = cb2d.checked;
      localStorage.setItem("showStadiums", showStadiums ? "on" : "off");
      updateStadiumVisibility();
    });
  }

  if(cb3d){
    cb3d.addEventListener("change", () => {
      showStadiums3d = cb3d.checked;
      localStorage.setItem("showStadiums3d", showStadiums3d ? "on" : "off");
      if(stadium3dLayer) stadium3dLayer._requestRender?.();
    });
  }

  cbFx.addEventListener("change", () => {
    showFixtureTravel = cbFx.checked;
    localStorage.setItem("showFixtureTravel", showFixtureTravel ? "on" : "off");
    if(!showFixtureTravel){
      stopAllFixtureTravel({ restore: true });
    } else {
      ensureFixtureTravelLayer();
      planFixtureTravelForToday();
    }
    // Info overlay is useful with travel, so keep it in sync.
    renderFixtureInfoMarkers();
    ensureFixtureInfoLayer();
    updateOverlayStatus();
  });

  cbFxInfo.addEventListener("change", () => {
    showFixtureInfo = cbFxInfo.checked;
    localStorage.setItem("showFixtureInfo", showFixtureInfo ? "on" : "off");
    renderFixtureInfoMarkers();
    ensureFixtureInfoLayer();
    renderMatchScoreboard();
    updateOverlayStatus();
  });

  cbMs.addEventListener("change", () => {
    showMatchScoreboard = cbMs.checked;
    localStorage.setItem("showMatchScoreboard", showMatchScoreboard ? "on" : "off");

    // When the top scoreboard is on, the old floating fixture info boxes usually look cluttered.
    // Keep the toggle available, but default to hiding them.
    if(showMatchScoreboard && showFixtureInfo){
      showFixtureInfo = false;
      localStorage.setItem("showFixtureInfo", "off");
      try{ cbFxInfo.checked = false; } catch {}
      renderFixtureInfoMarkers();
      ensureFixtureInfoLayer();
    }

    renderMatchScoreboard();
  });

  cbCompact.addEventListener("change", () => {
    compactOverlays = cbCompact.checked;
    localStorage.setItem("compactOverlays", compactOverlays ? "on" : "off");
    applyOverlayUiMode();
    renderFixtureInfoMarkers();
    renderMatchScoreboard();
  });

  fxBtn.addEventListener("click", async () => {
    await refreshFixturesAndTravel();
    await refreshScoresAndOverlay();
    renderMatchScoreboard();
  });

  fxFetchBtn.addEventListener("click", async () => {
    fxFetchBtn.disabled = true;
    const oldText = fxFetchBtn.textContent;
    fxFetchBtn.textContent = "Fetching…";
    try{
      await checkLocalApiHealth({ silent: false });
      // Requires running `python server.py` (not plain http.server) so /api/fetch-fixtures exists.
      const resp = await fetch('/api/fetch-fixtures', { method: 'POST' });
      const payload = await resp.json().catch(() => null);
      if(!resp.ok || !payload || payload.ok !== true){
        const msg = payload && (payload.message || payload.error || payload.stderr) ? String(payload.message || payload.error || payload.stderr) : `HTTP ${resp.status}`;
        throw new Error(msg);
      }

      toast(`Fixtures updated. ${payload.stdout || ''}`.trim() || 'Fixtures updated.');
      await refreshFixturesAndTravel();
      await refreshScoresAndOverlay();
    } catch (e){
      const msg = (e && e.message) ? e.message : String(e);
      toast(`Fetch fixtures failed: ${msg}`);
    } finally {
      fxFetchBtn.disabled = false;
      fxFetchBtn.textContent = oldText;
      await checkLocalApiHealth({ silent: true });
    }
  });

  fxTestBtn.addEventListener("click", () => {
    // Force-enable the feature
    showFixtureTravel = true;
    cbFx.checked = true;
    localStorage.setItem("showFixtureTravel", "on");

    // Build a synthetic fixture whose timeline is compressed to ~45 seconds.
    const now = Date.now();
    const kickoff = new Date(now + 15_000).toISOString();

    fixturesToday = [
      {
        matchDate: ukDateYYYYMMDD(new Date()),
        kickoff,
        homeId: "bristol_city",
        awayId: "derby_county",
        home: "Bristol City",
        away: "Derby County",
        competition: "TEST"
      }
    ];

    // Temporarily speed up the experience by overriding the planned windows in-place.
    planFixtureTravelForToday();
    renderFixtureInfoMarkers();
    ensureFixtureInfoLayer();
    const t = fixtureTravelActiveByAwayId.get("derby_county");
    if(t){
      t.travelOutStartMs = now - 15_000;   // started 15s ago
      t.kickoffMs = now + 15_000;          // reaches stadium in 15s
      t.matchEndMs = now + 25_000;         // short "match"
      t.travelBackEndMs = now + 45_000;    // returns home
    }

    // Zoom/fly to Bristol City so you can see Derby arriving.
    const home = _clubById.get("bristol_city");
    if(home){
      map.flyTo([home.lat, home.lon], Math.max(8, map.getZoom()), { duration: 0.8 });
    }

    ensureFixtureTravelLayer();
    ensureFixtureInfoLayer();
    updateOverlayStatus();
  });

  if(testBtn){
    testBtn.addEventListener("click", () => {
      // Ensure toggles are on
      showStadiums3d = true;
      if(cb3d) cb3d.checked = true;
      localStorage.setItem("showStadiums3d", "on");

      // Fly to the first mapped 3D club (most reliable sanity check)
      const mappedIds = stadiums3dByClubId ? Object.keys(stadiums3dByClubId) : [];
      if(!mappedIds.length){
        alert("No 3D mappings found in stadiums3d.json yet.");
        return;
      }

      const clubId = mappedIds[0];
      const club = clubs && clubs.find(c => String(c.id) === String(clubId));
      if(!club){
        alert(`Mapped club not found in clubs.json: ${clubId}`);
        return;
      }

      const targetZoom = Math.max(STADIUM3D_MIN_ZOOM + 2, map.getZoom());
      map.flyTo([club.lat, club.lon], targetZoom, { duration: 0.8 });
      if(stadium3dLayer) stadium3dLayer._requestRender?.();
    });
  }

  return wrap;
}



/* ===================== UTIL ===================== */
function safePlay(audioEl) {
  if (!audioEl) return;
  if (localStorage.getItem("soundEnabled") === "off") return;
  try {
    audioEl.currentTime = 0;
    audioEl.play().catch(() => {});
  } catch {}
}

function toast(message){
  const container = document.getElementById("toast-container");
  if(!container) return;
  const el = document.createElement("div");
  el.style.padding = "10px 14px";
  el.style.background = "#111";
  el.style.color = "var(--yellow)";
  el.style.border = "1px solid var(--green)";
  el.style.fontSize = "15px";
  el.style.maxWidth = "420px";
  el.style.boxShadow = "0 0 6px rgba(0,255,0,0.4)";
  el.style.whiteSpace = "pre-wrap";
  el.textContent = String(message || "");
  container.appendChild(el);

  setTimeout(() => {
    el.style.transition = "opacity 0.5s";
    el.style.opacity = "0";
    setTimeout(() => el.remove(), 500);
  }, 4500);
}

function showToast(club, title, link) {
  const toast = document.createElement("div");
  toast.style.padding = "10px 14px";
  toast.style.background = "#111";
  toast.style.color = "var(--yellow)";
  toast.style.border = "1px solid var(--green)";
  toast.style.fontSize = "15px";
  toast.style.cursor = "pointer";
  toast.style.maxWidth = "300px";
  toast.style.boxShadow = "0 0 6px rgba(0,255,0,0.4)";
  toast.textContent = `${club.name}: ${title}`;
  toast.onclick = () => {
    showClub(club, true);
    map.flyTo([club.lat, club.lon], 13, { duration: 0.6 });
  };

  const container = document.getElementById("toast-container");
  container.appendChild(toast);

  setTimeout(() => {
    toast.style.transition = "opacity 0.5s";
    toast.style.opacity = "0";
    setTimeout(() => toast.remove(), 500);
  }, 4000);
}


function decodeHTMLEntities(text){
  // Some feeds arrive double-encoded (e.g. "&amp;#8216;" -> "&#8216;" -> "‘").
  // Decode a few times until stable.
  let out = String(text ?? "");
  for(let i = 0; i < 4; i++){
    const txt = document.createElement("textarea");
    txt.innerHTML = out;
    const next = txt.value;
    if(next === out) break;
    out = next;
  }
  return out;
}

/* ===================== FIXTURES (Away travel) ===================== */
function ukDateYYYYMMDD(d = new Date()){
  // Stable YYYY-MM-DD in Europe/London (so “today” matches UK matchdays).
  try{
    return new Intl.DateTimeFormat('en-CA', {
      timeZone: 'Europe/London',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit'
    }).format(d);
  } catch {
    // fallback: local
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const day = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${day}`;
  }
}

function normalizeTeamName(s){
  return String(s || "")
    .toLowerCase()
    .replace(/&/g, 'and')
    .replace(/[^a-z0-9]+/g, ' ')
    .trim();
}

function fixtureKeyFromParts(homeId, awayId, kickoffMs){
  const k = kickoffMs ? String(kickoffMs) : "0";
  return `${String(homeId)}__${String(awayId)}__${k}`;
}

function simpleHash01(str){
  // Deterministic 0..1 (not crypto; just for spreading icons around a point).
  let h = 2166136261;
  const s = String(str || "");
  for(let i = 0; i < s.length; i++){
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  // Convert to 0..1
  return ((h >>> 0) % 1000000) / 1000000;
}

function getOpponentParkingLatLng(homeLatLng, awayId){
  if(!map || !homeLatLng) return homeLatLng;
  const z = map.getZoom ? map.getZoom() : 10;
  const t = Math.max(0, Math.min(1, (z - 6) / 10));
  const radius = FIXTURE_PARK_RADIUS_PX_MIN + (FIXTURE_PARK_RADIUS_PX_MAX - FIXTURE_PARK_RADIUS_PX_MIN) * t;
  const a = simpleHash01(awayId) * Math.PI * 2;
  const basePt = map.latLngToContainerPoint(homeLatLng);
  const pt = L.point(basePt.x + Math.cos(a) * radius, basePt.y + Math.sin(a) * radius);
  return map.containerPointToLatLng(pt);
}

function getSmartFixtureLabelLatLng(anchorLatLng, fixtureKey){
  if(!map || !anchorLatLng) return anchorLatLng;

  const size = map.getSize();
  const base = map.latLngToContainerPoint(anchorLatLng);
  const pad = FIXTURE_INFO_EDGE_PAD_PX;
  const halfW = FIXTURE_INFO_BOX_W_PX / 2;
  const h = FIXTURE_INFO_BOX_H_PX;

  // Candidate offsets in px (x, y). y negative = above.
  const candidates = [
    [0, -FIXTURE_LABEL_OFFSET_Y_PX],
    [0, FIXTURE_LABEL_OFFSET_Y_PX + 18],
    [halfW + 28, -36],
    [-(halfW + 28), -36],
    [halfW + 36, 22],
    [-(halfW + 36), 22],
  ];

  // Deterministic rotation so multiple fixtures don't all pick the same direction.
  const rot = Math.floor(simpleHash01(fixtureKey) * candidates.length);
  const rotated = candidates.slice(rot).concat(candidates.slice(0, rot));

  function scorePoint(pt){
    // With iconAnchor [halfW,0], box extends left/right by halfW and down by h.
    const left = pt.x - halfW;
    const right = pt.x + halfW;
    const top = pt.y;
    const bottom = pt.y + h;

    const inside = (left >= pad) && (right <= size.x - pad) && (top >= pad) && (bottom <= size.y - pad);
    if(!inside) return -1;

    // Prefer more margin from edges.
    const m = Math.min(left - pad, (size.x - pad) - right, top - pad, (size.y - pad) - bottom);
    return m;
  }

  let bestPt = null;
  let bestScore = -1;

  for(const [dx, dy] of rotated){
    const pt = L.point(base.x + dx, base.y + dy);
    const sc = scorePoint(pt);
    if(sc > bestScore){
      bestScore = sc;
      bestPt = pt;
    }
  }

  // If nothing fits, clamp an "above" placement into the viewport.
  if(!bestPt){
    const pt = L.point(base.x, base.y - FIXTURE_LABEL_OFFSET_Y_PX);
    const clampedX = Math.max(pad + halfW, Math.min(size.x - pad - halfW, pt.x));
    const clampedY = Math.max(pad, Math.min(size.y - pad - h, pt.y));
    bestPt = L.point(clampedX, clampedY);
  }

  return map.containerPointToLatLng(bestPt);
}

function formatKickoff(kickoffMs){
  if(!kickoffMs) return "KO: —";
  try{
    return new Intl.DateTimeFormat('en-GB', {
      timeZone: 'Europe/London',
      weekday: 'short',
      hour: '2-digit',
      minute: '2-digit'
    }).format(new Date(kickoffMs));
  } catch {
    return new Date(kickoffMs).toLocaleString();
  }
}

function setActiveFixtureKey(key){
  window.__activeFixtureKey = key || null;
  renderMatchScoreboard();
  applyFixtureInfoFadeMode();
}

function applyFixtureInfoFadeMode(){
  if(!map) return;
  const z = map.getZoom ? map.getZoom() : 10;
  const shouldFade = z < FIXTURE_INFO_FADE_BELOW_ZOOM;
  for(const [key, marker] of fixtureInfoMarkers.entries()){
    const el = marker && marker.getElement ? marker.getElement() : null;
    if(!el) continue;
    const isActive = (window.__activeFixtureKey && String(window.__activeFixtureKey) === String(key));
    el.classList.toggle('fixture-active', !!isActive);
    el.classList.toggle('fixture-faded', !!shouldFade && !isActive);
  }
}

function pickDefaultFixtureKey(){
  const list = fixturesToday || [];
  if(!list.length) return null;
  const now = Date.now();
  const liveLike = (s) => {
    if(!s) return false;
    if(typeof s.minute === 'number') return true;
    const st = String(s.status || '').toLowerCase();
    return /live|in play|1st|2nd|half|ht|ft|aet|pens/.test(st);
  };

  let bestLive = null;
  let bestLiveMinute = -1;
  let bestUpcoming = null;
  let bestUpcomingT = Infinity;
  let bestAny = null;
  let bestAnyT = Infinity;

  for(const fx of list){
    const kickoffMs = parseFixtureKickoffMs(fx) || 0;
    const homeId = resolveClubId(fx.homeId || fx.home || (fx.homeTeam && (fx.homeTeam.id || fx.homeTeam.name)) || fx.homeTeamName);
    const awayId = resolveClubId(fx.awayId || fx.away || (fx.awayTeam && (fx.awayTeam.id || fx.awayTeam.name)) || fx.awayTeamName);
    if(!homeId || !awayId) continue;

    const key = fixtureKeyFromParts(homeId, awayId, kickoffMs);
    const score = getScoreForFixtureKey(key) || getScoreForFixtureKey(fixtureKeyFromParts(homeId, awayId, 0));
    const t = kickoffMs || 9e15;

    if(liveLike(score)){
      const m = (score && typeof score.minute === 'number') ? score.minute : 0;
      if(m > bestLiveMinute){ bestLiveMinute = m; bestLive = key; }
      continue;
    }

    if(kickoffMs && kickoffMs >= now && t < bestUpcomingT){
      bestUpcomingT = t;
      bestUpcoming = key;
    }

    if(t < bestAnyT){ bestAnyT = t; bestAny = key; }
  }

  return bestLive || bestUpcoming || bestAny;
}

function renderMatchScoreboard(){
  const wrap = document.getElementById('match-scoreboard');
  if(!wrap) return;
  if(!showMatchScoreboard){ wrap.style.display = 'none'; return; }

  const key = window.__activeFixtureKey || pickDefaultFixtureKey();
  if(!key){ wrap.style.display = 'none'; return; }

  const parts = String(key).split('__');
  const homeId = parts[0];
  const awayId = parts[1];
  const kickoffMs = Number(parts[2] || 0);
  const home = _clubById.get(homeId);
  const away = _clubById.get(awayId);
  if(!home || !away){ wrap.style.display = 'none'; return; }

  // Find matching fixture object for meta.
  let fxObj = null;
  for(const fx of (fixturesToday || [])){
    const km = parseFixtureKickoffMs(fx) || 0;
    const hid = resolveClubId(fx.homeId || fx.home || (fx.homeTeam && (fx.homeTeam.id || fx.homeTeam.name)) || fx.homeTeamName);
    const aid = resolveClubId(fx.awayId || fx.away || (fx.awayTeam && (fx.awayTeam.id || fx.awayTeam.name)) || fx.awayTeamName);
    const k2 = hid && aid ? fixtureKeyFromParts(hid, aid, km) : null;
    if(k2 === key){ fxObj = fx; break; }
  }

  const score = getScoreForFixtureKey(key) || getScoreForFixtureKey(fixtureKeyFromParts(homeId, awayId, 0));
  const hs = (score && score.homeScore != null) ? score.homeScore : '—';
  const as = (score && score.awayScore != null) ? score.awayScore : '—';
  const st = score ? (score.minute != null ? `${score.minute}' ${score.status || ''}`.trim() : (score.status || '')) : '';

  const metaEl = document.getElementById('ms-meta');
  const subEl = document.getElementById('ms-sub');
  const statusEl = document.getElementById('ms-status');

  const comp = fxObj && fxObj.competition ? String(fxObj.competition) : '';
  const koText = kickoffMs ? formatKickoff(kickoffMs) : '—';
  const venue = home.ground ? String(home.ground) : '';

  if(metaEl){
    metaEl.textContent = [comp, koText].filter(Boolean).join(' • ') || '—';
  }
  if(subEl){
    subEl.textContent = venue ? `Venue: ${venue}` : '—';
  }
  if(statusEl){
    statusEl.textContent = st ? `Status: ${st}` : 'Status: —';
  }

  const hName = document.getElementById('ms-home-name');
  const aName = document.getElementById('ms-away-name');
  const hCrest = document.getElementById('ms-home-crest');
  const aCrest = document.getElementById('ms-away-crest');
  const hScore = document.getElementById('ms-home-score');
  const aScore = document.getElementById('ms-away-score');

  if(hName) hName.textContent = home.name;
  if(aName) aName.textContent = away.name;
  if(hScore) hScore.textContent = String(hs);
  if(aScore) aScore.textContent = String(as);
  if(hCrest){
    hCrest.src = home.logo || '';
    hCrest.style.display = home.logo ? '' : 'none';
  }
  if(aCrest){
    aCrest.src = away.logo || '';
    aCrest.style.display = away.logo ? '' : 'none';
  }

  wrap.style.display = '';
}

function ensureFixtureInfoLayer(){
  if(!map) return;
  const shouldShow = showFixtureInfo && map.getZoom() >= FIXTURE_TRAVEL_MIN_ZOOM;
  if(shouldShow){
    if(!map.hasLayer(fixtureInfoLayer)) fixtureInfoLayer.addTo(map);
  } else {
    if(map.hasLayer(fixtureInfoLayer)) map.removeLayer(fixtureInfoLayer);
  }
}

function scoreKeyForFixture(fx, kickoffMs){
  const homeId = resolveClubId(fx.homeId || fx.home || (fx.homeTeam && (fx.homeTeam.id || fx.homeTeam.name)) || fx.homeTeamName);
  const awayId = resolveClubId(fx.awayId || fx.away || (fx.awayTeam && (fx.awayTeam.id || fx.awayTeam.name)) || fx.awayTeamName);
  return homeId && awayId ? fixtureKeyFromParts(homeId, awayId, kickoffMs) : null;
}

function getScoreForFixtureKey(key){
  return key ? liveScoresByKey.get(key) : null;
}

async function loadScores(){
  try{
    const url = `${SCORES_URL}?v=${Date.now()}`;
    const data = await fetch(url).then(r => r.ok ? r.json() : null);
    if(!Array.isArray(data)) return [];
    return data;
  } catch {
    return [];
  }
}

function ingestScores(scores){
  const m = new Map();
  for(const s of (scores || [])){
    const homeId = resolveClubId(s.homeId || s.home || s.homeTeam);
    const awayId = resolveClubId(s.awayId || s.away || s.awayTeam);
    const kickoffMs = s.kickoff ? Date.parse(String(s.kickoff)) : (s.kickoffMs || null);
    if(!homeId || !awayId) continue;
    const key = fixtureKeyFromParts(homeId, awayId, kickoffMs || 0);
    m.set(key, {
      homeId,
      awayId,
      kickoffMs: kickoffMs || 0,
      homeScore: (typeof s.homeScore === 'number') ? s.homeScore : null,
      awayScore: (typeof s.awayScore === 'number') ? s.awayScore : null,
      status: s.status || '',
      minute: (typeof s.minute === 'number') ? s.minute : null
    });
  }
  liveScoresByKey = m;
}

function renderFixtureInfoMarkers(){
  // Clear and rebuild from fixturesToday for simplicity.
  fixtureInfoMarkers.clear();
  fixtureInfoLayer.clearLayers();
  if(!map) return;
  if(!showFixtureInfo) return;

  // Only show fixture overlays for the currently selected club.
  if(!selectedClubId) return;

  for(const fx of (fixturesToday || [])){
    const kickoffMs = parseFixtureKickoffMs(fx) || 0;
    const homeId = resolveClubId(fx.homeId || fx.home || (fx.homeTeam && (fx.homeTeam.id || fx.homeTeam.name)) || fx.homeTeamName);
    const awayId = resolveClubId(fx.awayId || fx.away || (fx.awayTeam && (fx.awayTeam.id || fx.awayTeam.name)) || fx.awayTeamName);
    if(!homeId || !awayId) continue;

    if(String(homeId) !== String(selectedClubId) && String(awayId) !== String(selectedClubId)){
      continue;
    }
    const home = _clubById.get(homeId);
    const away = _clubById.get(awayId);
    if(!home || !away) continue;

    const key = fixtureKeyFromParts(homeId, awayId, kickoffMs);
    const score = getScoreForFixtureKey(key) || getScoreForFixtureKey(fixtureKeyFromParts(homeId, awayId, 0));
    const scoreText = (score && score.homeScore != null && score.awayScore != null)
      ? `${score.homeScore}-${score.awayScore}`
      : "—";
    const statusText = score
      ? (score.minute != null ? `${score.minute}' ${score.status || ''}`.trim() : (score.status || ''))
      : '';

    const homeLL = L.latLng(home.lat, home.lon);
    const labelLL = getSmartFixtureLabelLatLng(homeLL, key);

    const ko = formatKickoff(kickoffMs);
    const hLogo = home.logo || '';
    const aLogo = away.logo || '';
    const hNameShort = home.shortName || home.name;
    const aNameShort = away.shortName || away.name;
    const metaLeft = ko ? ko : '—';
    const metaRight = statusText ? statusText : '—';

    const html = `
      <div class="fixture-info-box">
        <div class="fx-mini-main">
          <div class="fx-mini-team left">
            <img class="fx-mini-crest" alt="" src="${hLogo}" style="display:${hLogo ? 'block' : 'none'}">
            <div class="fx-mini-name">${hNameShort}</div>
          </div>
          <div class="fx-mini-score" aria-label="score">
            <div class="fx-mini-score-num">${(score && score.homeScore != null) ? score.homeScore : '—'}</div>
            <div class="fx-mini-score-sep"></div>
            <div class="fx-mini-score-num">${(score && score.awayScore != null) ? score.awayScore : '—'}</div>
          </div>
          <div class="fx-mini-team right">
            <div class="fx-mini-name">${aNameShort}</div>
            <img class="fx-mini-crest" alt="" src="${aLogo}" style="display:${aLogo ? 'block' : 'none'}">
          </div>
        </div>
        <div class="fx-mini-meta">
          <div>${metaLeft}</div>
          <div class="fx-mini-status">${metaRight}</div>
        </div>
      </div>
    `;

    const marker = L.marker(labelLL, {
      icon: L.divIcon({
        className: 'leaflet-div-icon fixture-info-icon',
        html,
        iconSize: [260, 0],
        iconAnchor: [130, 0]
      }),
      pane: 'fixtureInfoPane',
      zIndexOffset: 15000,
      interactive: true,
      keyboard: false
    });

    marker.on('add', () => {
      applyFixtureInfoFadeMode();
    });

    marker.on('click', () => {
      map.flyTo([home.lat, home.lon], Math.max(9, map.getZoom()), { duration: 0.6 });
      showClub(home, true);
      setSelectedClubOnMap(homeId);
      try{
        showMatchScoreboard = true;
        localStorage.setItem("showMatchScoreboard", "on");
        const cb = document.getElementById('cbMatchScoreboard');
        if(cb) cb.checked = true;
      } catch {}
      setActiveFixtureKey(key);
    });

    fixtureInfoLayer.addLayer(marker);
    fixtureInfoMarkers.set(key, marker);
  }

  ensureFixtureInfoLayer();
  applyFixtureInfoFadeMode();
}

async function refreshScoresAndOverlay(){
  const prev = (liveScoresByKey instanceof Map) ? liveScoresByKey : new Map();
  const scores = await loadScores();
  ingestScores(scores);

  // Establish baseline without alert spam.
  if(!_scoresInitialized){
    _scoresInitialized = true;
    renderFixtureInfoMarkers();
    renderMatchScoreboard();
    updateOverlayStatus();
    return;
  }

  let anyGoal = false;

  for(const [key, now] of liveScoresByKey.entries()){
    const before = prev.get(key);
    if(!before) continue;

    const bh = (typeof before.homeScore === 'number') ? before.homeScore : null;
    const ba = (typeof before.awayScore === 'number') ? before.awayScore : null;
    const nh = (typeof now.homeScore === 'number') ? now.homeScore : null;
    const na = (typeof now.awayScore === 'number') ? now.awayScore : null;
    if(bh == null || ba == null || nh == null || na == null) continue;

    const dHome = nh - bh;
    const dAway = na - ba;
    if(dHome <= 0 && dAway <= 0) continue;

    const home = _clubById.get(String(now.homeId));
    const away = _clubById.get(String(now.awayId));
    if(!home || !away) continue;

    const minuteBit = (now.minute != null) ? ` (${now.minute}')` : (now.status ? ` (${now.status})` : "");
    const scoreText = `${nh}-${na}`;

    const emitGoal = (scoringClub) => {
      anyGoal = true;
      const title = `GOAL: ${scoringClub.name}! ${home.name} ${scoreText} ${away.name}${minuteBit}`;
      const link = "#";

      addRumour(scoringClub.id, {
        title,
        link,
        time: new Date().toISOString(),
        source: "Goal"
      });
      unreadCounts[scoringClub.id] = (unreadCounts[scoringClub.id] || 0) + 1;
      autoOpenPathForClub(scoringClub);

      // Treat like incoming news.
      updateTicker("Goal", title, link);
      showToast(scoringClub, title, link);
    };

    if(dHome > 0) emitGoal(home);
    if(dAway > 0) emitGoal(away);
  }

  if(anyGoal){
    if(!viewClubId) renderDirectory();
    safePlay(sndNews);
  }

  renderFixtureInfoMarkers();
  renderMatchScoreboard();
  updateOverlayStatus();
}

function rebuildClubLookups(){
  _clubAliasToId = new Map();
  _clubById = new Map();
  for(const c of (clubs || [])){
    const id = String(c.id);
    _clubById.set(id, c);
    _clubAliasToId.set(normalizeTeamName(c.name), id);
    _clubAliasToId.set(normalizeTeamName(id), id);
    if(Array.isArray(c.aliases)){
      for(const a of c.aliases){
        const k = normalizeTeamName(a);
        if(k) _clubAliasToId.set(k, id);
      }
    }
  }
}

function resolveClubId(ref){
  if(ref == null) return null;
  const s = String(ref);
  if(_clubById.has(s)) return s;
  const key = normalizeTeamName(s);
  if(_clubAliasToId.has(key)) return _clubAliasToId.get(key);
  return null;
}

function parseFixtureKickoffMs(fx){
  const raw = fx && (fx.kickoff || fx.kickoffUtc || fx.kickoffISO || fx.dateTime);
  if(!raw) return null;
  const t = Date.parse(String(raw));
  return Number.isFinite(t) ? t : null;
}

async function loadFixtures(){
  fixtureTravelStatus.lastError = null;
  fixtureTravelStatus.lastLoad = null;
  try{
    const url = `${FIXTURES_URL}?v=${Date.now()}`;
    const data = await fetch(url).then(r => r.ok ? r.json() : null);
    fixtureTravelStatus.lastLoad = Date.now();
    if(!Array.isArray(data)) return [];
    return data;
  } catch (e){
    fixtureTravelStatus.lastError = String(e && e.message ? e.message : e);
    return [];
  }
}

function filterFixturesForToday(fixtures){
  const today = ukDateYYYYMMDD(new Date());
  return (fixtures || []).filter(fx => {
    // Accept either explicit matchDate or kickoff ISO.
    if(fx && fx.matchDate){
      return String(fx.matchDate) === today;
    }
    const t = parseFixtureKickoffMs(fx);
    if(!t) return false;
    return ukDateYYYYMMDD(new Date(t)) === today;
  });
}

function ensureFixtureTravelLayer(){
  if(!map) return;
  const shouldShow = showFixtureTravel && map.getZoom() >= FIXTURE_TRAVEL_MIN_ZOOM;
  if(shouldShow){
    if(!map.hasLayer(fixtureTravelLayer)) fixtureTravelLayer.addTo(map);
  } else {
    if(map.hasLayer(fixtureTravelLayer)) map.removeLayer(fixtureTravelLayer);
  }
}

function stopAllFixtureTravel({ restore = true } = {}){
  if(_fixtureTravelTimer){
    clearInterval(_fixtureTravelTimer);
    _fixtureTravelTimer = null;
  }

  for(const [awayId, t] of fixtureTravelActiveByAwayId.entries()){
    try{ if(t.trailOut) fixtureTravelLayer.removeLayer(t.trailOut); } catch {}
    try{ if(t.trailBack) fixtureTravelLayer.removeLayer(t.trailBack); } catch {}
    if(restore){
      const marker = clubMarkers.get(awayId);
      if(marker && t.fromLatLng) marker.setLatLng(t.fromLatLng);

      const stadiumMarker = stadiumMarkers.get(awayId);
      if(stadiumMarker && t.fromLatLng) stadiumMarker.setLatLng(t.fromLatLng);
    }
  }
  fixtureTravelActiveByAwayId.clear();
  fixtureTravelLayer.clearLayers();
  fixtureTravelStatus.active = 0;
}

function planFixtureTravelForToday(){
  stopAllFixtureTravel({ restore: true });
  ensureFixtureTravelLayer();
  if(!showFixtureTravel) return;

  const now = Date.now();
  const todays = fixturesToday || [];
  fixtureTravelStatus.total = todays.length;
  fixtureTravelStatus.resolved = 0;
  fixtureTravelStatus.active = 0;

  for(const fx of todays){
    const homeId = resolveClubId(fx.homeId || fx.home || (fx.homeTeam && fx.homeTeam.id) || (fx.homeTeam && fx.homeTeam.name) || fx.homeTeamName);
    const awayId = resolveClubId(fx.awayId || fx.away || (fx.awayTeam && fx.awayTeam.id) || (fx.awayTeam && fx.awayTeam.name) || fx.awayTeamName);
    if(!homeId || !awayId) continue;
    if(homeId === awayId) continue;

    const home = _clubById.get(homeId);
    const away = _clubById.get(awayId);
    if(!home || !away) continue;

    const kickoffMs = parseFixtureKickoffMs(fx) || now;
    const travelOutStartMs = kickoffMs - FIXTURE_TRAVEL_HOURS_BEFORE_KO * 3600_000;
    const matchEndMs = kickoffMs + FIXTURE_MATCH_DURATION_HOURS * 3600_000;
    const travelBackEndMs = matchEndMs + FIXTURE_RETURN_DURATION_HOURS * 3600_000;

    const fromLatLng = L.latLng(away.lat, away.lon);
    const toLatLng = L.latLng(home.lat, home.lon);

    fixtureTravelStatus.resolved++;

    const trailOut = L.polyline([fromLatLng], {
      color: '#ff00ff',
      weight: 3,
      opacity: 0.9,
      className: 'fixture-trail',
      dashArray: '6 10'
    });
    fixtureTravelLayer.addLayer(trailOut);

    const trailBack = L.polyline([toLatLng], {
      color: '#00ffff',
      weight: 3,
      opacity: 0.85,
      className: 'fixture-trail-return',
      dashArray: '3 8'
    });
    fixtureTravelLayer.addLayer(trailBack);

    fixtureTravelActiveByAwayId.set(awayId, {
      awayId,
      homeId,
      fromLatLng,
      toLatLng,
      kickoffMs,
      travelOutStartMs,
      matchEndMs,
      travelBackEndMs,
      trailOut,
      trailBack,
      lastTrailOutAt: 0,
      lastTrailBackAt: 0,
      lastPos: fromLatLng
    });
  }

  fixtureTravelStatus.active = fixtureTravelActiveByAwayId.size;

  // Run a lightweight interval for predictable CPU usage.
  _fixtureTravelTimer = setInterval(() => {
    if(!showFixtureTravel) return;
    if(!map || map.getZoom() < FIXTURE_TRAVEL_MIN_ZOOM) return;
    const now2 = Date.now();

    for(const t of fixtureTravelActiveByAwayId.values()){
      const marker = clubMarkers.get(t.awayId);
      if(!marker) continue;

      const parkedAtOpponent = getOpponentParkingLatLng(t.toLatLng, t.awayId);

      let pos = t.fromLatLng;
      let mode = 'home';

      if(now2 < t.travelOutStartMs){
        pos = t.fromLatLng;
        mode = 'home';
      } else if(now2 < t.kickoffMs){
        // outbound travel 0..1
        const denom = Math.max(1, (t.kickoffMs - t.travelOutStartMs));
        let p = (now2 - t.travelOutStartMs) / denom;
        p = Math.max(0, Math.min(1, p));
        const eased = p < 0.5 ? 2*p*p : 1 - Math.pow(-2*p + 2, 2)/2;
        pos = L.latLng(
          t.fromLatLng.lat + (parkedAtOpponent.lat - t.fromLatLng.lat) * eased,
          t.fromLatLng.lng + (parkedAtOpponent.lng - t.fromLatLng.lng) * eased
        );
        mode = 'out';
      } else if(now2 < t.matchEndMs){
        pos = parkedAtOpponent;
        mode = 'at_match';
      } else if(now2 < t.travelBackEndMs){
        // return travel 0..1
        const denom = Math.max(1, (t.travelBackEndMs - t.matchEndMs));
        let p = (now2 - t.matchEndMs) / denom;
        p = Math.max(0, Math.min(1, p));
        const eased = p < 0.5 ? 2*p*p : 1 - Math.pow(-2*p + 2, 2)/2;
        pos = L.latLng(
          parkedAtOpponent.lat + (t.fromLatLng.lat - parkedAtOpponent.lat) * eased,
          parkedAtOpponent.lng + (t.fromLatLng.lng - parkedAtOpponent.lng) * eased
        );
        mode = 'back';
      } else {
        pos = t.fromLatLng;
        mode = 'home';
      }

      marker.setLatLng(pos);
      const stadiumMarker = stadiumMarkers.get(t.awayId);
      if(stadiumMarker) stadiumMarker.setLatLng(pos);

      if(mode === 'out'){
        const shouldSample = (now2 - (t.lastTrailOutAt || 0)) >= FIXTURE_TRAIL_SAMPLE_MS;
        if(shouldSample){
          t.trailOut.addLatLng(pos);
          t.lastTrailOutAt = now2;
        }
      } else if(mode === 'back'){
        const shouldSample = (now2 - (t.lastTrailBackAt || 0)) >= FIXTURE_TRAIL_SAMPLE_MS;
        if(shouldSample){
          t.trailBack.addLatLng(pos);
          t.lastTrailBackAt = now2;
        }
      }
      t.lastPos = pos;
    }
  }, FIXTURE_TRAVEL_TICK_MS);
}

async function refreshFixturesAndTravel(){
  const all = await loadFixtures();
  fixturesToday = filterFixturesForToday(all);
  planFixtureTravelForToday();
  renderFixtureInfoMarkers();
  ensureFixtureInfoLayer();
  updateOverlayStatus();
}

function escapeRegex(s){
  return (s || "").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function normaliseKey(str){
  return (str || "").trim().toLowerCase();
}

function makeSeenKey(source, title, link){
  return `${source}||${normaliseKey(title)}||${normaliseKey(link)}`;
}

function leagueKey(countryName, leagueName){
  return `${countryName}|||${leagueName}`;
}

/* ===================== MATCHING ===================== */
/* Title-only matching (prevents cookie banner garbage). */
function matchClubByTitle(title){
  const t = (title || "").toLowerCase();
  return clubs.find(c =>
    (c.aliases || []).some(a => {
      const k = (a || "").toLowerCase();
      if(!k) return false;
      if(k.length <= 2) return new RegExp(`\\b${escapeRegex(k)}\\b`, "i").test(t);
      return t.includes(k);
    })
  );
}

/* ===================== TICKER ===================== */
function updateTicker(label, title, link){
  const cleanTitle = decodeHTMLEntities(title);
  tickerTextEl.textContent = `${label.toUpperCase()}: ${cleanTitle}`;

  // clickable to link
  tickerLinkEl.href = link || "#";

  const icon = FEED_ICONS[label];
  if(icon){
    tickerIconEl.src = icon;
    tickerIconEl.style.display = "";
    tickerIconEl.onerror = () => { tickerIconEl.style.display = "none"; };
  } else {
    tickerIconEl.style.display = "none";
  }

// 🧠 Fly to marker and animate if club found
const club = matchClubByTitle(title);
if (club) {
const marker = clubMarkers.get(club.id);
if (marker) {
  const latlng = marker.getLatLng();
  const currentZoom = map.getZoom();
  const targetZoom = 9;

  if (currentZoom < targetZoom) {
    map.flyTo(latlng, targetZoom, { duration: 0.6 });
  } else {
    map.panTo(latlng, { duration: 0.4 });
  }


    // Play helicopter sound at 40% volume
    if (sndHeli) {
      sndHeli.volume = 0.4;
      sndHeli.currentTime = 0;
      sndHeli.play().catch(() => {});
    }

    // Animate the marker badge (pulse + glow)
    triggerClubNewsAlertOnMap(club.id);

  }

  // Highlight club row in sidebar
  const row = document.getElementById(`club-${club.id}`);
if (row) {
  row.classList.add("selected-club");
  setTimeout(() => row.classList.remove("selected-club"), 1600);
}


    // Show temporary overlay
    const overlay = document.createElement("div");
    overlay.textContent = club.name;
    overlay.style.position = "absolute";
    overlay.style.top = "10px";
    overlay.style.left = "50%";
    overlay.style.transform = "translateX(-50%)";
    overlay.style.background = "black";
    overlay.style.color = "var(--yellow)";
    overlay.style.padding = "6px 12px";
    overlay.style.border = "2px solid var(--yellow)";
    overlay.style.fontFamily = "Teletext, monospace";
    overlay.style.zIndex = 9999;
    overlay.style.pointerEvents = "none";
    overlay.style.fontSize = "18px";

    document.body.appendChild(overlay);
    setTimeout(() => overlay.remove(), 2000);
  }
}
function showToast(club, title, link) {
  const toast = document.createElement("div");
  toast.style.padding = "10px 14px";
  toast.style.background = "#111";
  toast.style.color = "var(--yellow)";
  toast.style.border = "1px solid var(--green)";
  toast.style.fontSize = "15px";
  toast.style.cursor = "pointer";
  toast.style.maxWidth = "300px";
  toast.style.boxShadow = "0 0 6px rgba(0,255,0,0.4)";
  toast.textContent = `${club.name}: ${title}`;
  toast.onclick = () => {
    showClub(club, true);
    map.flyTo([club.lat, club.lon], 13, { duration: 0.6 });
  };

  const container = document.getElementById("toast-container");
  container.appendChild(toast);

  setTimeout(() => {
    toast.style.transition = "opacity 0.5s";
    toast.style.opacity = "0";
    setTimeout(() => toast.remove(), 500);
  }, 4000);
}


/* ===================== SIDEBAR RENDER ===================== */
function buildTree(){
  const tree = {};
  clubs.forEach(c => {
    const country = COUNTRY_NAMES[c.country] || c.country || "UNKNOWN";
    const league = c.league || "UNKNOWN";
    if(!tree[country]) tree[country] = {};
    if(!tree[country][league]) tree[country][league] = [];
    tree[country][league].push(c);
  });

  for(const country of Object.keys(tree)){
    for(const league of Object.keys(tree[country])){
      tree[country][league].sort((a,b)=>a.name.localeCompare(b.name));
    }
  }
  return tree;
}

function renderDirectory(){
  viewClubId = null;
  clearTimeout(viewTimeout);

  const tree = buildTree();
  sidebar.innerHTML = "";
  const searchBox = document.createElement("input");
  searchBox.type = "text";
  searchBox.placeholder = "Search clubs…";
  searchBox.style.width = "100%";
  searchBox.style.marginBottom = "8px";
  searchBox.style.padding = "6px";
  searchBox.style.fontFamily = "inherit";
  searchBox.style.background = "black";
  searchBox.style.color = "var(--green)";
  searchBox.style.border = "1px solid var(--green)";
  searchBox.style.outline = "none";

sidebar.appendChild(searchBox);
// Auto-refresh toggle
const refreshToggle = document.createElement("label");
refreshToggle.style.display = "block";
refreshToggle.style.marginBottom = "12px";
refreshToggle.style.fontSize = "14px";
refreshToggle.style.color = "var(--cyan)";
refreshToggle.style.userSelect = "none";
sidebar.appendChild(refreshToggle);

const checkbox = document.createElement("input");
checkbox.type = "checkbox";
checkbox.checked = localStorage.getItem("autoRefresh") !== "off";
checkbox.style.marginRight = "6px";

refreshToggle.appendChild(checkbox);
refreshToggle.appendChild(document.createTextNode("Auto-refresh news"));

checkbox.addEventListener("change", () => {
  localStorage.setItem("autoRefresh", checkbox.checked ? "on" : "off");
});

sidebar.appendChild(refreshToggle);
// Sound toggle
const soundToggle = document.createElement("label");
soundToggle.style.display = "block";
soundToggle.style.marginBottom = "12px";
soundToggle.style.fontSize = "14px";
soundToggle.style.color = "var(--magenta)";
soundToggle.style.userSelect = "none";

const soundCheckbox = document.createElement("input");
soundCheckbox.type = "checkbox";
soundCheckbox.checked = localStorage.getItem("soundEnabled") !== "off";
soundCheckbox.style.marginRight = "6px";

soundToggle.appendChild(soundCheckbox);
soundToggle.appendChild(document.createTextNode("Enable sound"));
sidebar.appendChild(soundToggle);

soundCheckbox.addEventListener("change", () => {
  localStorage.setItem("soundEnabled", soundCheckbox.checked ? "on" : "off");
});

  // Stadium toggles (2D/3D) in sidebar for discoverability
  sidebar.appendChild(createStadiumSidebarPanel());

  sidebar.scrollTop = 0;

  const preferredCountries = ["England","Scotland","Wales","Northern Ireland","Republic of Ireland"];
  const countries = [
    ...preferredCountries.filter(c => tree[c]),
    ...Object.keys(tree).filter(c => !preferredCountries.includes(c)).sort()
  ];

  countries.forEach(country => {
    const countryBlock = document.createElement("div");

    const cHeader = document.createElement("div");
    cHeader.className = "country-header";
    const cOpen = openCountries.has(country);
    cHeader.innerHTML = `
      <img class="flag" src="flags/${country.slice(0,3).toUpperCase()}.png" onerror="this.style.display='none'">
      <span class="twisty">${cOpen ? "▼" : "▶"}</span>
      <span>${country}</span>
    `;

    const leaguesDiv = document.createElement("div");
    leaguesDiv.style.display = cOpen ? "block" : "none";

    cHeader.addEventListener("click", () => {
      if(openCountries.has(country)){
        openCountries.delete(country);
        userClosedCountries.add(country);
      } else {
        openCountries.add(country);
        userClosedCountries.delete(country);
      }
      renderDirectory();
      safePlay(sndClick);
    });

    const order = LEAGUE_ORDER[country] || Object.keys(tree[country]).sort();
    order.forEach(league => {
      if(!tree[country][league]) return;

      const lKey = leagueKey(country, league);
      const lOpen = openLeagues.has(lKey);

      const lBlock = document.createElement("div");
      lBlock.className = "league";

      const lHeader = document.createElement("div");
      lHeader.className = "league-header";
      lHeader.innerHTML = `
        <img class="league-crest" src="league_crests/${league.replace(/\s+/g,"_")}.png" onerror="this.style.display='none'">
        <span class="twisty">${lOpen ? "▼" : "▶"}</span>
        <span>${league}</span>
      `;

      const clubsDiv = document.createElement("div");
      clubsDiv.style.display = lOpen ? "block" : "none";

      lHeader.addEventListener("click", (e) => {
        e.stopPropagation();
        if(openLeagues.has(lKey)){
          openLeagues.delete(lKey);
          userClosedLeagues.add(lKey);
        } else {
          openLeagues.add(lKey);
          userClosedLeagues.delete(lKey);
        }
        renderDirectory();
        safePlay(sndClick);
      });

      let leagueHasUnread = false;

      tree[country][league].forEach(club => {
        const row = document.createElement("div");
        row.className = "club";
        row.id = `club-${club.id}`;

        const dot = document.createElement("span");
        dot.className = "club-dot";

        const label = document.createElement("span");
        label.textContent = club.name;

        row.appendChild(dot);
        row.appendChild(label);

        const u = unreadCounts[club.id] || 0;
        if(u > 0){
          leagueHasUnread = true;
          row.classList.add("active");
          const count = document.createElement("span");
          count.className = "count";
          count.textContent = `(${u})`;
          row.appendChild(count);
        }

row.addEventListener("click", (e) => {
  e.stopPropagation();
  showClub(club, true);

  const marker = clubMarkers.get(club.id);
  if (marker) {
    const latlng = marker.getLatLng();
    map.flyTo(latlng, map.getZoom(), { duration: 0.6 });


  }
});


        clubsDiv.appendChild(row);
      });

      if(leagueHasUnread){
        lHeader.classList.add("active");
        cHeader.classList.add("active");
      }

      lBlock.appendChild(lHeader);
      lBlock.appendChild(clubsDiv);
      leaguesDiv.appendChild(lBlock);
    });

    countryBlock.appendChild(cHeader);
    countryBlock.appendChild(leaguesDiv);
    sidebar.appendChild(countryBlock);
  });

  sidebar.insertAdjacentHTML("beforeend", `<div class="hint">TIP: Click a club to view latest items. Unread clubs blink red.</div>`);
  // Filter clubs on input
searchBox.addEventListener("input", () => {
  const filter = searchBox.value.trim().toLowerCase();
  document.querySelectorAll(".club").forEach(clubEl => {
    const label = clubEl.querySelector("span:nth-child(2)");
    const name = label?.textContent.toLowerCase() || "";
    clubEl.style.display = name.includes(filter) ? "" : "none";
  });
});

  localStorage.setItem("openCountries", JSON.stringify([...openCountries]));
  localStorage.setItem("openLeagues", JSON.stringify([...openLeagues]));

}

function showClub(club, playSound) {
  viewClubId = club.id;
  clearTimeout(viewTimeout);

  setSelectedClubOnMap(club.id);

  if (playSound) safePlay(sndClick);
  unreadCounts[club.id] = 0;

  sidebar.innerHTML = "";

  const back = document.createElement("div");
  back.className = "back";
  back.textContent = "◀ BACK";
  back.addEventListener("click", () => {
    safePlay(sndBack);
    renderDirectory();
  });

  const titleWrap = document.createElement("div");
  titleWrap.className = "club-view-header";

  const name = document.createElement("div");
  name.className = "club-name";
  name.textContent = club.name;

  titleWrap.appendChild(name);

  sidebar.appendChild(back);
  sidebar.appendChild(titleWrap);

  // Stadium toggles (2D/3D) in club view too
  sidebar.appendChild(createStadiumSidebarPanel());

  const items = (rumoursByClub.get(club.id) || []).slice(0, 20).sort(
    (a, b) => new Date(b.time) - new Date(a.time)
  );

  if (items.length === 0) {
    sidebar.insertAdjacentText("beforeend", "NO ACTIVE STORIES");
  } else {
    for (const r of items) {
      const card = document.createElement("div");
      card.className = "rumour";

      const a = document.createElement("a");
      a.href = r.link;
      a.target = "_blank";
      a.rel = "noopener noreferrer";
      a.textContent = r.title;

      const meta = document.createElement("div");
      meta.className = "time";
      meta.innerHTML = `${r.time} — <span class="source">${r.source}</span>`;

      card.appendChild(a);
      card.appendChild(meta);
      sidebar.appendChild(card);
    }
  }

  // Scroll to top of sidebar
  sidebar.scrollTop = 0;

  // Highlight selected club in sidebar
  document.querySelectorAll(".club").forEach(el => el.classList.remove("selected-club"));
  const selectedRow = document.getElementById(`club-${club.id}`);
  if (selectedRow) {
    selectedRow.classList.add("selected-club");
  }

  // Auto-back after timeout
  viewTimeout = setTimeout(() => {
    if (viewClubId === club.id) renderDirectory();
  }, AUTO_BACK_TIMEOUT_MS);
}

/* ===================== NEWS INGEST ===================== */
function addRumour(clubId, rumour){
  const arr = rumoursByClub.get(clubId) || [];
  arr.unshift(rumour);
  if(arr.length > MAX_RUMOURS_PER_CLUB) arr.length = MAX_RUMOURS_PER_CLUB;
  rumoursByClub.set(clubId, arr);
}

function autoOpenPathForClub(club){
  const country = COUNTRY_NAMES[club.country] || club.country || "UNKNOWN";
  const league = club.league || "UNKNOWN";
  const lk = leagueKey(country, league);

  if(!userClosedCountries.has(country)) openCountries.add(country);
  if(!userClosedLeagues.has(lk)) openLeagues.add(lk);
}

/* ===================== POLLING ===================== */
async function fetchFeed(label, url){
  const api = `https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent(url)}`;
  const res = await fetch(api);
  if(!res.ok) return null;
  const data = await res.json();
  return data && data.items ? data.items : [];
}

async function pollTick(){
  if(FEEDS.length === 0) return;
const autoRefresh = localStorage.getItem("autoRefresh");
if (autoRefresh && autoRefresh !== "on") return;


  const batch = [];
  for(let i=0; i<FEEDS_PER_TICK; i++){
    const idx = (feedIndex + i) % FEEDS.length;
    batch.push(FEEDS[idx]);
  }
  feedIndex = (feedIndex + FEEDS_PER_TICK) % FEEDS.length;

  let anyNew = false;

  for(const [label, url] of batch){
    try{
      const items = await fetchFeed(label, url);
      const sliced = items.slice(0, MAX_ITEMS_PER_FEED);

      for(const item of sliced){
        const rawTitle = item.title || "";
        const link = item.link || "";
        const key = makeSeenKey(label, rawTitle, link);
        if(seenKeys.has(key)) continue;
        if (tickerTextEl.textContent.includes(rawTitle)) continue;

        // Mark seen early to reduce repeats
        seenKeys.add(key);

        // MATCH club on TITLE ONLY
        const club = matchClubByTitle(decodeHTMLEntities(rawTitle));
        if(!club) continue;

        const cleanTitle = decodeHTMLEntities(rawTitle);

        // Store rumour
        addRumour(club.id, {
          title: cleanTitle,
          link: link,
          time: item.pubDate || "RSS",
          source: label
        });

        unreadCounts[club.id] = (unreadCounts[club.id] || 0) + 1;

        // auto-open that country/league unless user explicitly closed
        autoOpenPathForClub(club);

        // update ticker (clickable)
        updateTicker(label, cleanTitle, link);
        showToast(club, cleanTitle, link);

        anyNew = true;

        // if in directory view, rerender to update counters consistently
        if(!viewClubId){
          renderDirectory();
        }
      }
    } catch(e){
      // ignore feed failures (lots of sources)
    }
  }

  if(anyNew){
    safePlay(sndNews);
  }
}

/* ===================== INIT ===================== */
async function init(){
  clubs = await fetch("clubs.json").then(r => r.json());
  rebuildClubLookups();

  if(!DISABLE_STADIUM_OVERLAYS){
    // Optional: stadium renders overlay (clubId -> relative image path)
    stadiumsByClubId = await fetch("stadiums.json")
      .then(r => r.ok ? r.json() : {})
      .catch(() => ({}));

    loadCustomStadiums();

    // Optional: 3D stadium overlay mapping (clubId -> { url, scale, rotationDeg, yOffsetPx })
    stadiums3dByClubId = await fetch("stadiums3d.json")
      .then(r => r.ok ? r.json() : {})
      .catch(() => ({}));
  } else {
    stadiumsByClubId = {};
    stadiums3dByClubId = {};
  }

  // Optional: fixtures feed (drives away-team travel)
  try{
    await refreshFixturesAndTravel();
  } catch {}

  // Optional: live scores feed (updates the fixture info overlay)
  try{
    await refreshScoresAndOverlay();
  } catch {}

  // Restore saved open/closed state
  const savedCountries = localStorage.getItem("openCountries");
  const savedLeagues = localStorage.getItem("openLeagues");
  if (savedCountries) openCountries = new Set(JSON.parse(savedCountries));
  else openCountries = new Set();

  if (savedLeagues) openLeagues = new Set(JSON.parse(savedLeagues));
  else openLeagues = new Set();

  userClosedCountries = new Set();
  userClosedLeagues = new Set();

  for(const c of clubs){
    rumoursByClub.set(c.id, []);
    unreadCounts[c.id] = 0;
  }

  renderDirectory();
  drawMap();
  if(!DISABLE_STADIUM_OVERLAYS) drawStadiums();

  updateOverlayStatus();

  if(!DISABLE_STADIUM_OVERLAYS && ensureThreeAvailable()){
    stadium3dLayer = new ThreeStadiumLayer();
    stadium3dLayer.addTo(map);
    stadium3dLayer.setData(clubs, stadiums3dByClubId);
    map.on("zoomend", () => stadium3dLayer && stadium3dLayer._requestRender && stadium3dLayer._requestRender());
  }

  if(!DISABLE_STADIUM_OVERLAYS){
    addStadiumToggleControl();
    map.on("zoomend", updateStadiumVisibility);
  }
  map.on("zoomend", updateOverlayStatus);
  map.on("zoomend", ensureFixtureTravelLayer);
  map.on("zoomend", () => {
    ensureFixtureInfoLayer();
    renderFixtureInfoMarkers();
    applyFixtureInfoFadeMode();
  });
  map.on("moveend", () => {
    renderFixtureInfoMarkers();
    applyFixtureInfoFadeMode();
  });
  ensureFixtureTravelLayer();
  ensureFixtureInfoLayer();
  checkLocalApiHealth({ silent: true });
  if(_apiHealthTimer) clearInterval(_apiHealthTimer);
  _apiHealthTimer = setInterval(() => checkLocalApiHealth({ silent: true }), 30000);
  await pollTick();
  setInterval(pollTick, POLL_EVERY_MS);

  if(_scorePollTimer) clearInterval(_scorePollTimer);
  _scorePollTimer = setInterval(() => {
    refreshScoresAndOverlay();
  }, SCORE_POLL_EVERY_MS);
}


// Run after DOMContentLoaded so deferred module scripts (Three.js) have executed.
if (document.readyState === "loading") {
  window.addEventListener("DOMContentLoaded", () => {
    init();
    scheduleBigBenHourly();
  });
} else {
  init();
  scheduleBigBenHourly();
}

// === HOURLY BELLS ===
function scheduleBigBenHourly() {
  const now = new Date();
  const minutes = now.getMinutes();
  const seconds = now.getSeconds();
  const millisecondsUntilNextHour = ((59 - minutes) * 60 + (60 - seconds)) * 1000;

  setTimeout(() => {
    sndBells.play().catch(() => {});
    setInterval(() => {
      sndBells.play().catch(() => {});
    }, 60 * 60 * 1000); // every hour
  }, millisecondsUntilNextHour);
}



</script>
</body>
</html>
